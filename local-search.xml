<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git学习手记</title>
    <link href="/2022/09/03/Git%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/"/>
    <url>/2022/09/03/Git%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE基础补充计划</title>
    <link href="/2022/09/01/JavaSE%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2022/09/01/JavaSE%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-SE基础补完计划"><a href="#Java-SE基础补完计划" class="headerlink" title="Java SE基础补完计划"></a>Java SE基础补完计划</h1><blockquote><p>Java SE基础是Java学习中的基石，后续的学习基本都需要依靠这些基础内容，如果这一部分的内容掌握不牢固，就会导致后续学习内容的晦涩难懂。</p><p>基于以上原因，加上自我感觉Java SE的内容可能只掌握了60%，因此完成这份补完计划十分重要。Java SE大体可以分为三个部分：</p><ul><li>Java基础语法：包括面向对象编程、集合、异常、反射等</li><li>操作系统相关：多线程，IO流等</li><li>数据结构与算法：表、树、哈希、KMP、动态规划等</li></ul><p>参考文档&amp;教程&amp;书籍</p><ul><li><a href="https://www.yuque.com/qingkongxiaguang/javase/xoxpqi">Java SE 笔记</a></li><li><a href="https://www.runoob.com/java/java-tutorial.html">Java教程-菜鸟教程</a></li><li>《Java 核心技术卷》</li></ul></blockquote><hr><h2 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h2><h3 id="Java语法与使用规范"><a href="#Java语法与使用规范" class="headerlink" title="Java语法与使用规范"></a>Java语法与使用规范</h3><p>对于Java的语法和使用规范是十分基础的东西，具体的内容可以参照文档&amp;教程&amp;书籍中的内容进行了解学习。</p><p>主要的内容包括：Java中的关键字，变量和常量，注释，基本数据类型以及数据类型之间的转换，运算符，流程控制。</p><p>了解完Java的语法和使用规范之后，就可以进行下一部分。</p><hr><h2 id="Java对象与多态"><a href="#Java对象与多态" class="headerlink" title="Java对象与多态"></a>Java对象与多态</h2><h3 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h3><p>面向对象程序设计（OOP）是当今主流的程序设计范式，而Java是面向对象的，必须熟悉OOP才能编写Java程序。</p><p>在使用OOP时，需要从对象的三个主要特性入手，分别是行为，状态（对象的状态不会自发改变，必须通过调用方法实现）和标识。对象这三个主要特性在彼此之间互相影响。</p><blockquote><p>传统的结构化程序设计通过设计一系列的过程（或者说算法）来求解问题，一旦确定了过程，就要考虑存储数据的方式。这也是Nikalus Wirth编著的《算法+数据结构&#x3D;程序》中，标题第一位是算法，第二位是数据结构的原因<br><em>面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。实际上，在面向对象中，只要对象可以满足要求，就不关心功能的具体实现过程，只需要满足用户的需求。</em> </p><p>​——Java核心技术卷</p></blockquote><h3 id="Java中的类"><a href="#Java中的类" class="headerlink" title="Java中的类"></a>Java中的类</h3><p>Java中的对象都基于类创建，这些类可以是Java自带的类，也可以是程序员自己编写的类。<strong>简单来说，类是对象的一个模板，有自己的属性，包括成员变量，成员方法等，我们可以通过调用类的成员方法来进行一些操作。</strong>（这里可以看下菜鸟教程：<a href="https://www.runoob.com/java/java-object-classes.html">Java对象和类</a>）</p><p>在使用面向对象程序设计时，经常需要分析用户的需求，识别出需要使用和设计的类。识别类最简单的方法就是在分析问题的过程中寻找名词，这些名词就代表着类，而方法由动词对应。当然，在实际开发中，更多的还是得依赖于个人的开发经验。</p><p>在Java中，类的加载机制也需要注意。类并不是在一开始就全部加载好，而是在需要时才会去加载，目的是提高速度，如以下情况下会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new创建对象的实例</li><li>调用类的静态方法</li><li>子类初始化</li><li>以及特殊情况</li></ul><p><strong>类与类之间，存在着三种常见的关系：</strong></p><ul><li>依赖（uses-a）：如果一个类的方法操纵另一个类的对象，就可以说一个类依赖于另一个类。在开发中，应该尽可能将相互依赖的类减少，使用术语来说，就是让类之间的耦合度最低。</li><li>聚合（has-a）：这个关系其实可以从英语出发，就是一个对象中存在另外一些对象，这样就可以说类与类之间存在聚合关系。其实我们更应该理解为包含。</li><li>继承（is-a）：继承是一种用于表示特殊与一般关系的。可以理解为社会中的父子关系。<em>（注意，继承内容是Java中非常重要的部分，笔者自身已经反复学习理解过多次，如果新手读者建议找找教程视频深刻学习体会）</em></li></ul><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p>抽象类和接口，其实就是类的抽象再抽象。</p><p>对于类的初步抽象，就是保留特征而不保留具体形态。比如对于方法，在抽象类中我可以定义却不去实现，保留给子类实现。</p><p>对抽象类的抽象，也即是对类的深度抽象，就是接口了。严格说它甚至不是一个类，只代表了某个功能，只包含对方法的定义。<strong>接口的功能需要由主体——也就是类来实现</strong>。</p><ul><li><a href="https://www.runoob.com/java/java-abstraction.html">Java 抽象类 | 菜鸟教程</a></li><li><a href="https://www.runoob.com/java/java-abstraction.html">Java 接口 | 菜鸟教程</a></li></ul><h3 id="包装类和枚举类"><a href="#包装类和枚举类" class="headerlink" title="包装类和枚举类"></a>包装类和枚举类</h3><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>虽然说Java是一种面向对象的语言，不过Java也不是完全面向对象的。例如Java中的基本数据类型就不是对象。当我们想通过对象的方式去使用基本数据类型时，就需要将其转换为相对应的对象。Java中提供这一服务的类就称之为包装类，将基本数据类型转换为对象的过程称为打包（装箱），反过来的过程称为拆包（拆箱）。这两个过程在Java中可以自动完成，也可以由程序员自己编写。</p><p><img src="/img/class1.jpg" alt="包装类"></p><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>有时候，我们想为对象添加一个描述或者一种状态（例如衣服的尺码有小、中、大、加大等，人的状态有睡觉、工作，吃饭等）。如果此时我们使用字符串来存储这一部分数据，就有可能出现外部传来的数据并不是我们想要的。这个时候，就可以使用枚举类来解决这个问题，这样就只能使用我们定义好的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//服装尺码的枚举类</span><br><span class="hljs-comment">//实际上，这句代码定义了一个类，这个类有这四个实例，所以在使用枚举类时，尽量不要构造新对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL , MEDIUM , LARGE , EXTRA_LARGE&#125;;<br></code></pre></td></tr></table></figure><p>此外，所有枚举类都是Enum类的子类，也就是说继承了Enum类的许多方法可以使用。</p><hr><h2 id="Java的异常机制与异常处理"><a href="#Java的异常机制与异常处理" class="headerlink" title="Java的异常机制与异常处理"></a>Java的异常机制与异常处理</h2><blockquote><p>一个程序的使用过程中不可能完全不存在BUG，代码跑不动才是常态。这是很正常的现象，关键是要在出现BUG之后优化程序，使之不断改进，不断趋于完美。</p><p>在Java 核心技术卷中建议在出现异常时，至少应该做到：</p><ul><li>向用户通告错误</li><li>保存所有的操作结果</li><li>允许用户以适当的形式退出程序</li></ul></blockquote><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p><img src="/img/ExceptionClass.jpg" alt="异常层次结构体系"></p><p>从上图其实可以很清晰的看出，Java中的异常其实也是一个类，继承自Throwable类，分为两种：Error类和Exception，其中Exception类还有IOException和RuntimeException两个子类。当然，如果现有的类不足以满足用户的需求，同样可以自己编写需要的子类。</p><ul><li>Error类描述的是Java运行是系统的内部错误和资源耗尽错误。如果出现了这样的内部错误，程序除了通告给用户同时尽力安全地终止程序外，其他的也无能为力。这种情况在实际开发很少出现。</li><li>Exception类是在开发中需要重点关注的部分。一般来说，由程序错误导致的异常术语RuntimeException；如果程序本身没有问题，不过由于 I&#x2F;O 错误这类问题导致的异常属于IOException。<ul><li>RuntimeException的异常还包括：错误的类型转换，数组访问越界，访问空指针</li><li>IOException的异常还包括：试图的文件尾部后面读取数据，试图打开一个错误格式的URL，试图根据给定的字符串查找Class对象，但是字符串表示的类并不存在</li></ul></li></ul><h3 id="异常的抛出，捕获及自定义"><a href="#异常的抛出，捕获及自定义" class="headerlink" title="异常的抛出，捕获及自定义"></a>异常的抛出，捕获及自定义</h3><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>如果调用方法时因为传入错误的参数，进而导致程序无法正常运行，此时应该手动抛出一个异常来终止程序，然后报告上一级方法执行出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;   <span class="hljs-comment">//捕获方法中会出现的异常</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>        <span class="hljs-comment">//声明抛出的异常类型</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;0不能做除数！&quot;</span>);  <span class="hljs-comment">//创建异常对象并抛出异常</span><br>        <span class="hljs-keyword">return</span> a/b;  <span class="hljs-comment">//抛出异常会终止代码运行</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>如果调用编译时异常的方法，但是依然不想去处理，可以同样的在方法上声明 throws 来继续交给上一级处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <span class="hljs-comment">//出现异常就再往上抛，而不是在此方法内处理</span><br>  test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <span class="hljs-comment">//声明抛出的异常类型</span><br>  <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;0不能做除数！&quot;</span>);  <span class="hljs-comment">//创建异常对象并抛出异常      </span><br>  <span class="hljs-keyword">return</span> a/b;  <br>&#125;<br></code></pre></td></tr></table></figure><p>出现类似以上代码的情况，连main方法都声明抛出异常时，这时出现的异常就会交给JVM处理，JVM会直接终止程序并在控制台打印栈追踪信息（这也是默认的处理方法）</p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>抛出一个异常十分容易，只要将它抛出就行了。不过，一些代码必须捕获异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    some code...<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    some code...<br>&#125;<br></code></pre></td></tr></table></figure><p>try&#x2F;catch语句是捕获一个异常必须设置的。<strong>如果try代码块中抛出了一个在catch子句中说明的异常，那么，首先程序会跳过try代码块中的其余代码，执行catch中的处理器代码。如果没有出现任何异常，则不会执行catch中的代码。如果出现没有声明的异常类型，那么程序就会立刻退出。</strong></p><blockquote><p>编译器严格执行throws说明符，如果调用一个抛出已检查异常（非派生于Error类和RuntimeException类的异常）的方法，就必须对它进行处理，或者将其传递出去（即抛出）。</p><p>通常，应捕获那些知道如何处理的异常，传递那些不知道怎么处理的异常。如果想将异常传出去，就必须在方法的首部添加一个throws说明符，以便告知调用者这个方法可能会抛出异常。</p><p>阅读Java API文档，以便知道每个方法可能会抛出的异常，然后决定是自己处理，还是添加到throws列表里。对后一种，不必犹豫，将异常直接交给能够胜任的处理器进行处理会比压制对它的处理更好。</p><p>​——《Java核心技术卷》</p></blockquote><p><strong>对于捕获多个异常来说，就是在try&#x2F;catch语句基础上，再多加入声明不同异常类型的catch语句。</strong></p><p>此外，还可以在catch语句中再抛出一个异常，这样做的目的一般是改变异常的类型。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>异常的自定义非常简单，只要继承部分的知识掌握的足够，自定义异常的编写更多是对父类方法的重写。</p><hr><h3 id="Java中的断言，日志和调试"><a href="#Java中的断言，日志和调试" class="headerlink" title="Java中的断言，日志和调试"></a>Java中的断言，日志和调试</h3><h4 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h4><p>在程序设计中，代码运行测试是必不可少的，这就要求在程序中插入测试代码。一般的测试代码在测试完成后不会自动删除，大量的测试代码会导致程序的运行变慢。</p><p>断言机制就是允许在测试时向代码插入检查语句，到代码发布时，这些插入的语句将会被自动的移走。Java中引入 assert 关键字来使用断言。</p><p>不过，在现在的开发中，断言并不推荐使用。详见：<a href="https://developer.aliyun.com/article/409118">Java陷阱之assert关键字</a></p><hr><h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><h3 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h3><p>泛型，其实就是为了编写的代码可以被不同<strong>类型对象</strong>所使用。</p><p>在没使用泛型之前，代码可能是这样写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>&#123;<br>    <span class="hljs-keyword">private</span> String[] paraList; <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;...&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String para)</span>&#123;...&#125;;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这样一个List类，在使用时只能添加String类型的数据，如果要使用其他类型，好像得重写一下。有人可能会想到Object类，它是所有类的超类，修改如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>&#123;<br>    <span class="hljs-keyword">private</span> Object[] paraList; <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;...&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object para)</span>&#123;...&#125;;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><p>可是，这里一样会出现两个问题：</p><ul><li><p>获取一个值时必须进行强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>可以在数组中添加任何类的对象，容易导致一些无法预料的错误。</p></li></ul><p>基于以上原因，泛型的作用就凸显出来了。相同代码，完全可以这样编写（这里的T只能是类，不可以使用基本数据类型，可以使用包装类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>&lt;T&gt;&#123;<br>   <span class="hljs-keyword">private</span> T[] paraList; <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;...&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T para)</span>&#123;...&#125;;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定义泛型类-x2F-方法-x2F-接口"><a href="#定义泛型类-x2F-方法-x2F-接口" class="headerlink" title="定义泛型类&#x2F;方法&#x2F;接口"></a>定义泛型类&#x2F;方法&#x2F;接口</h3><p>泛型类就是具有一个或者多个类型变量的类。它的定义较为简单，参考上面的例子，使用一对尖括号（&lt;&gt;）将类型变量 T 括起来放在类名的后面。如果有多个，还可以使用K，V，U，S等，中间使用逗号隔开。</p><hr><h2 id="集合类和集合接口"><a href="#集合类和集合接口" class="headerlink" title="集合类和集合接口"></a>集合类和集合接口</h2><p>Java的类库中有这么一些类，可以帮助我没在程序设计中实现传统的数据结构，比如链表，堆栈，队列，散列表等等。数据结构是程序设计中必学的课程，也有许多相关的书籍介绍和讲解使用方法，此处不再赘述。</p><p>此外，在学习数据结构时，一般会穿插讲解算法，对于一般人来说，算法只需要了解几种常见的排序算法和查找算法即可，在了解的基础上懂得如何使用，以及理解实现过程便可，并不需要在深入了解算法。</p><hr><h2 id="Java中的多线程"><a href="#Java中的多线程" class="headerlink" title="Java中的多线程"></a>Java中的多线程</h2><p>多线程基础介绍部分，笔者之前就有写过博客，详见：<a href="https://blake315.github.io/2022/09/01/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/">Java多线程</a></p><p>内容有错误之处，欢迎指出。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven学习手记</title>
    <link href="/2022/09/01/maven%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/"/>
    <url>/2022/09/01/maven%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven——强力好用的Java项目管理工具"><a href="#Maven——强力好用的Java项目管理工具" class="headerlink" title="Maven——强力好用的Java项目管理工具"></a>Maven——强力好用的Java项目管理工具</h1><blockquote><p>Maven在美国是一个口语化的词语，意思是专家，内行。也相当于汉语中的老炮儿，老师傅。正所谓老炮儿在手，管理无忧。</p><p>我们要学的Maven，实际上是一个项目管理工具，可以对项目进行构建、依赖管理。经过发展，Maven已经不仅仅可以管理Java项目，也可以对例如Ruby，Scala等语言编写的项目进行项目管理。</p><p>参考教程&#x2F;文档：</p><ul><li><a href="http://mvnbook.com/index.html">Maven教程网</a></li><li><a href="https://wuhang.xyz/fa714294.html">学习使用Maven构建项目</a></li><li><a href="https://www.dba.cn/book/maven/">Maven中文手册</a></li></ul></blockquote><hr><h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><h3 id="Java项目管理工具的历史与发展"><a href="#Java项目管理工具的历史与发展" class="headerlink" title="Java项目管理工具的历史与发展"></a>Java项目管理工具的历史与发展</h3><p>对于Java项目管理工具，主要有三个主要工具，Ant、Maven以及Gradle（按照出现时间）。最开始的Java项目管理工具是Ant，之后才出现了Maven，严格来说，Ant和Maven之间是兄弟关系，都是Apache基金会的项目。对于现行的Java企业开发来说，Ant已经销声匿迹，而新出现的Gradle发展迅速，大有取代Maven地位的趋势，不过就目前来讲，Maven仍是Java项目管理工具中的王者。</p><p>对于三个管理工具的简单接受和分析，百科及大量的博客已有介绍，我也不再赘述，这里推荐一下朋友Matty写的简单介绍。（<a href="https://wuhang.xyz/fa714294.html">学习使用Maven构建项目</a>，1.2节）</p><h3 id="Maven的组成"><a href="#Maven的组成" class="headerlink" title="Maven的组成"></a>Maven的组成</h3><blockquote><p>Maven是一个项目管理工具，它包含了：项目对象模型 (POM，Project Object Model)，项目生命周期(Project Lifecycle)，依赖管理系统(Dependency Management System)和各种插件。插件主要用来实现生命周期各个阶段(phase)的目标(goal)。Maven的组成如下所示：</p><p><img src="http://mvnbook.com/static/image/maven-core.png" alt="概念模型"></p><p>不过，上述介绍对于完全没有 Maven 实践经验的人来说，看了等于没看，并没有用处。只有当读者通读本站内容之后，反过头再看，才能豁然开朗。(<a href="http://mvnbook.com/index.html">Maven教程网</a>）</p></blockquote><h3 id="Maven的特性"><a href="#Maven的特性" class="headerlink" title="Maven的特性"></a>Maven的特性</h3><ul><li><p><strong>依赖管理系统</strong>。Maven使用groupId，artifactId，version组成的“坐标”来标识依赖。当项目需要引入一个外部依赖时，只需在配置文件里添加几行代码；如果项目所依赖的Jar包需要升级时，只需要修改配置文件中的一行。</p></li><li><p><strong>多模块构建</strong>。</p><blockquote><p>在Maven中，可以为当前项目定义一个parent POM（实际上是一个pom.xml文件），该POM中可以使用modules配置来定义一组子模块。parent POM不会有实际构建的产出，但parent POM中的build配置以及dependencies配置都会自动继承给子模块。</p></blockquote></li><li><p><strong>一致的项目结构</strong>。Maven通过指定一套项目目录结构为标准的Java项目结构，解决了不同IDE带来的文件目录不一致的问题。</p><p>对于这个标准的项目目录结构，网上的讲解和图片非常多，另外这个目录一般都是Maven自动生成，我们只需要知道什么文件应该放在什么文件夹即可。</p><blockquote><p>推荐阅读：<a href="http://mvnbook.com/maven-standard-project-directory.html">Maven标准项目目录-Maven教程网</a></p></blockquote></li><li><p><strong>一致的构建模型和插件机制</strong></p></li></ul><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>学习Maven的准备工作分为两个部分，官网下载zip包并解压，配置环境变量。这里的具体步骤参考<a href="http://mvnbook.com/maven-download.html">Maven下载与安装</a></p><blockquote><p>我自己在按照教程配置环境变量的时候，出现了以下的一个报错： could not create the JAVA  virtual machine。经过搜索，发现这是由于MAVEN_OPTS设置异常导致。错误的地方非常好笑，就是变量配置少了一个空格。</p><p>还是那句话，要相信自己在配置过程中遇到的所有问题，都会有人遇到过，并且都能在网上找到解决方法。</p></blockquote><p>在执行第一次Maven命令时，默认会在用户目录下的.<em>m&#x2F;respository</em>中下载依赖，这个位置在Maven中称为仓库。如果需要修改，可以在Maven目录中的setting.xml文件中修改。（这里建议修改，方便文件管理）</p><hr><h2 id="Maven中的仓库"><a href="#Maven中的仓库" class="headerlink" title="Maven中的仓库"></a>Maven中的仓库</h2><p>在Maven中的任何一个依赖，插件或者项目构建时的输出，都称为”<strong>构件</strong>“。对于这些构件，Maven仓库都可以帮助我们管理。此外，仓库是一个位置，在项目中引入的第三方库的位置，在Maven中就称为仓库。</p><h3 id="仓库的原理"><a href="#仓库的原理" class="headerlink" title="仓库的原理"></a>仓库的原理</h3><p>我们使用Maven的第一目的就是可以更好的管理我们的项目（主要是Java项目），管理项目其实就是管理依赖和第三方库（也即是Jar包）。仓库本质上就是一个用来放置Jar包的地方。在本地开发时，会查看仓库中是否有Jar包，有就直接用，没有就从远程仓库下载。所以项目，本地仓库以及远程仓库的依赖关系就是：项目依赖于本地仓库，本地仓库依赖于远程仓库。</p><h3 id="三种Maven仓库类型"><a href="#三种Maven仓库类型" class="headerlink" title="三种Maven仓库类型"></a>三种Maven仓库类型</h3><ul><li>本地仓库（local）：本机放置构件的地方，Maven从远程仓库下载的构件都存放在此处。需要注意的是，本地仓库只有在执行第一次Maven命令时才会生成，默认路径在用户目录下一个.<em>m&#x2F;respository</em>中。如果需要修改，可以在Maven目录中的setting.xml文件中修改。</li><li>中央仓库（central）：这是Maven社区提供的仓库，里面包含常用类库。不过由于Maven社区的服务器在海外，国内访问下载类库的速度偏慢，有时候甚至会断连，针对这个原因，我们同样可以在Maven目录中的setting文件中修改配置文件，将下载地址变更为国内阿里的镜像网址。</li><li>远程私服（remote）：一般指公司内部使用的仓库。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程详解</title>
    <link href="/2022/09/01/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <url>/2022/09/01/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多线程详解"><a href="#Java多线程详解" class="headerlink" title="Java多线程详解"></a>Java多线程详解</h1><h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="多任务，多线程"><a href="#多任务，多线程" class="headerlink" title="多任务，多线程"></a>多任务，多线程</h3><p><strong>多任务</strong>情况中，虽然可以完成，但是实际上，多任务的完成是由一个一个小任务的完成来实现的，也就是说<em>在执行多任务时，不是同时执行多个任务，而是一个时间段内只完成一个任务。</em></p><p><strong>多线程</strong>情况中，则是<em>依赖于CPU的功能</em>，<em><strong>瞬间同时执行多个线程，或者说主线程和子线程并行交替执行。</strong></em></p><h3 id="程序-进程-线程"><a href="#程序-进程-线程" class="headerlink" title="程序 进程 线程"></a>程序 进程 线程</h3><ol><li><p><strong>程序</strong>就是指令和数据的有序集合，本身没有任何运行的含义，<strong>是一个静态的概念</strong></p></li><li><p><strong>进程</strong>是<em>执行程序的一次执行过程</em>，<strong>是一个动态的概念</strong></p></li><li><p><strong>线程</strong>包含在进程中，<em><strong>一个进程可以由多个线程，一个进程至少有一个线程（主线程main），线程是CPU调度和执行的单位</strong></em></p></li></ol><h3 id="线程的三种创建方式"><a href="#线程的三种创建方式" class="headerlink" title="线程的三种创建方式"></a>线程的三种创建方式</h3><ul><li><p>通过声明Thread类的子类，重写run类的方法Thread创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//继承Thread类，重写run方法中的代码块</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Testing01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//run方法代码块</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;run方法运行次数&quot;</span> + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//开启线程的方法：1.创建对象 2.调用start方法</span><br>        <span class="hljs-type">Testing01</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Testing01</span>();<br>        t1.start();<br>        <span class="hljs-comment">//主线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;主线程运行次数&quot;</span> + i);<br>        &#125;<br><span class="hljs-comment">//线程不一定是立即执行的，实际的执行需要看CPU的调度，基本  是随机调度，随机执行。因为CPU的执行一个线程的速度非常  快，所以我们感觉起来像是在同时执行多个线程，但是实际上是一个一个线程执行的</span><br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p>Thread类使用案例：下载网图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.io.FileUtils; <br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-comment">//联系Thread：实现多线程图片下载器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Testing02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><span class="hljs-comment">//声明私有变量</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String name;<br><span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Testing02</span><span class="hljs-params">(String url , String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">//下载图片的线程体</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">WebDownloader</span> <span class="hljs-variable">w1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebDownloader</span>();<br>        w1.downloader(url , name);<br>        System.out.println(<span class="hljs-string">&quot;下载了文件名为：&quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Testing02</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Testing02</span>(<span class="hljs-string">&quot;http://image.biaobaiju.com/uploads/20190227/22/1551276917-PGHykpWFAn.jpeg&quot;</span>,<span class="hljs-string">&quot;1.jpeg&quot;</span>);<br>        t1.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebDownloader</span>&#123;<br>    <span class="hljs-comment">//下载方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloader</span><span class="hljs-params">(String url , String name)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileUtils.copyURLToFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url) , <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(name));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;IO异常，downloader方法出现问题&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>通过实现Runnable创建线程</p><ul><li>定义Runnable类实现Runnable接口</li><li>实现run()方法，编写线程执行体</li><li>创建线程对象，调用start（）方法启动线程</li><li>runnable实现类的运行还需要借助创建Thread对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Testing03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//run方法线程体</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学代码&quot;</span> + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建runnable接口的实现类对象</span><br>        <span class="hljs-type">Testing03</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Testing03</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t3).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><em>一般在Java中推荐使用通过Runnable类实现线程，这是由Java的单继承性质决定的，使用Runnable接口，就可以实现用多个线程对同一对象进行操作了</em></p><p><em><strong>同样的，多线程操作同一个对象也带来一个问题，被操作的对象会很容易出现数据异常等问题，所以还需要通过Java并发控制来解决</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//模拟用户抢票（由于没有加入并发控制，所有执行结果会出现两个人抢到同一张票的错误）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Testing04</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//调用sleep方法，人为制造延迟</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ticketNums &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到了第&quot;</span> + ticketNums-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Testing04</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Testing04</span>();<br><span class="hljs-comment">//实现多线程操作同一个对象tt</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tt,<span class="hljs-string">&quot;小米&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tt,<span class="hljs-string">&quot;华为&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tt,<span class="hljs-string">&quot;oppo&quot;</span>).start();<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>实现Callable接口（了解即可）</p><ol><li><p>需要返回数值</p></li><li><p>重写call方法，需要抛出异常</p></li><li><p>创建目标对象</p></li><li><p>创建执行服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里有线程池的方法</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ser</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></li><li><p>提交执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;Boolean&gt; r1 = ser.submit(t1);<br>Future&lt;Boolean&gt; r2 = ser.submit(t2);<br>Future&lt;Boolean&gt; r3 = ser.submit(t3);<br></code></pre></td></tr></table></figure></li><li><p>获取结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">re1</span> <span class="hljs-operator">=</span> r1.get();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">re2</span> <span class="hljs-operator">=</span> r2.get();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">re3</span> <span class="hljs-operator">=</span> r3.get();<br></code></pre></td></tr></table></figure></li><li><p>关闭服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ser.shutdown();<br></code></pre></td></tr></table></figure></li></ol></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式的进化之路</title>
    <link href="/2022/09/01/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/09/01/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式的进化之路"><a href="#Lambda表达式的进化之路" class="headerlink" title="Lambda表达式的进化之路"></a>Lambda表达式的进化之路</h1><h2 id="为什么要使用Lambda表达式"><a href="#为什么要使用Lambda表达式" class="headerlink" title="为什么要使用Lambda表达式"></a>为什么要使用Lambda表达式</h2><ul><li>可以简洁代码，提高代码的可读性</li><li>可以避免匿名内部类定义过多导致逻辑紊乱</li><li>在原先实现接口抽象方法的时候，需要通过定义一个实现接口的外部类来实现，后面变为定义内部静态类，然后变为用局部内部类实现，再后面变成了定义匿名内部类来实现，最后的最后，为了代码的更加简洁，推出了Lambda表达式，最终实现了用一行代码完成之前多行代码的效果</li></ul><h2 id="Lambda表达式的注意点"><a href="#Lambda表达式的注意点" class="headerlink" title="Lambda表达式的注意点"></a>Lambda表达式的注意点</h2><ul><li><p><strong>Lambda表达式实际上属于是函数式编程的概念，所以在使用的时候要知道是否属于函数式编程</strong></p></li><li><p><strong>Lambda表达式的实现依赖于接口和父类，所以必须有两者之一才能实现Lam表达式</strong></p></li><li><p><strong>Lambda表达式实现的接口中要求只有一个抽象方法，如果有多个抽象方法就无法使用Lambda表达式来编程</strong></p></li><li><p><strong>Lambda表达式即适用于无参方法，也适用于含参方法</strong></p></li><li><p><em>Lambda表达式最早在JDK 8中开始出现，所以只有 JDK 8 以后的版本才支持</em></p><hr></li></ul><h3 id="下面是Lambda表达式的实现过程"><a href="#下面是Lambda表达式的实现过程" class="headerlink" title="下面是Lambda表达式的实现过程"></a>下面是Lambda表达式的实现过程</h3><ol><li><p><em><strong>最开始使用的是定义外部实现类来完成接口</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">tt1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//用外部类来实现接口，首先需要在主类外定义另外一个类，之后再在内部类中创建对象</span><br>        <span class="hljs-comment">//这样对于那些只需要使用一次的接口来说比较的麻烦，而且也会使整个代码变得臃肿，给其他开发人员带来阅读困难</span><br>        <span class="hljs-type">lover</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover</span>();<br>        l1.love();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILove</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//外部实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lover</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出为：I love you lover ---&gt; 1</span><br></code></pre></td></tr></table></figure></li><li><p><em><strong>开始使用静态内部类来实现</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">tt1</span> &#123;<br>    <span class="hljs-comment">//静态内部类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 2&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//用外部类来实现接口，首先需要在主类外定义另外一个类，之后再在内部类中创建对象</span><br>        <span class="hljs-comment">//这样对于那些只需要使用一次的接口来说比较的麻烦，而且也会使整个代码变得臃肿，给其他开发人员带来阅读困难</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover1</span>();<br>        l1.love();<br>        <span class="hljs-comment">//使用静态内部类来实现，由于实现类和main方法位于相同主类中，方便了开发人员阅读，但是实现过程还是比较麻烦</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover2</span>();<br>        l2.love();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个函数式接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILove</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//外部实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lover1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出为：I love you my lover ---&gt; 1</span><br><span class="hljs-comment">//   I love you my lover ---&gt; 2</span><br></code></pre></td></tr></table></figure></li><li><p><em><strong>使用局部内部类使用</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">tt1</span> &#123;<br>    <span class="hljs-comment">//静态内部类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 2&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//用外部类来实现接口，首先需要在主类外定义另外一个类，之后再在内部类中创建对象</span><br>        <span class="hljs-comment">//这样对于那些只需要使用一次的接口来说比较的麻烦，而且也会使整个代码变得臃肿，给其他开发人员带来阅读困难</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover1</span>();<br>        l1.love();<br>        <span class="hljs-comment">//使用静态内部类来实现，由于实现类和main方法位于相同主类中，方便了开发人员阅读，但是实现过程还是比较麻烦</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover2</span>();<br>        l2.love();<br><br>        <span class="hljs-comment">//局部内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 3&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover3</span>();<br>        l3.love();<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个函数式接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILove</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//外部实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lover1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出为：I love you my lover ---&gt; 1</span><br><span class="hljs-comment">// I love you my lover ---&gt; 2</span><br><span class="hljs-comment">// I love you my lover ---&gt; 3</span><br></code></pre></td></tr></table></figure></li><li><p><em><strong>使用匿名内部类实现接口</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">tt1</span> &#123;<br>    <span class="hljs-comment">//静态内部类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 2&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//用外部类来实现接口，首先需要在主类外定义另外一个类，之后再在内部类中创建对象</span><br>        <span class="hljs-comment">//这样对于那些只需要使用一次的接口来说比较的麻烦，而且也会使整个代码变得臃肿，给其他开发人员带来阅读困难</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover1</span>();<br>        l1.love();<br>        <span class="hljs-comment">//使用静态内部类来实现，由于实现类和main方法位于相同主类中，方便了开发人员阅读，但是实现过程还是比较麻烦</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover2</span>();<br>        l2.love();<br><br>        <span class="hljs-comment">//局部内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 3&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover3</span>();<br>        l3.love();<br><br>        <span class="hljs-comment">//使用内部匿名类</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ILove</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 4&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个函数式接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILove</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//外部实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lover1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出为：I love you my lover ---&gt; 1</span><br><span class="hljs-comment">//   I love you my lover ---&gt; 2</span><br><span class="hljs-comment">//   I love you my lover ---&gt; 3</span><br><span class="hljs-comment">//  I love you my lover ---&gt; 4</span><br></code></pre></td></tr></table></figure></li><li><p><em><strong>最后使用Lambda表达式实现函数式接口</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">tt1</span> &#123;<br>    <span class="hljs-comment">//静态内部类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 2&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//用外部类来实现接口，首先需要在主类外定义另外一个类，之后再在内部类中创建对象</span><br>        <span class="hljs-comment">//这样对于那些只需要使用一次的接口来说比较的麻烦，而且也会使整个代码变得臃肿，给其他开发人员带来阅读困难</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover1</span>();<br>        l1.love();<br>        <span class="hljs-comment">//使用静态内部类来实现，由于实现类和main方法位于相同主类中，方便了开发人员阅读，但是实现过程还是比较麻烦</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover2</span>();<br>        l2.love();<br><br>        <span class="hljs-comment">//局部内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 3&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover3</span>();<br>        l3.love();<br><br>        <span class="hljs-comment">//使用内部匿名类</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ILove</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 4&quot;</span>);<br>            &#125;<br>        &#125;;<br>        l4.love();<br><br>        <span class="hljs-comment">//使用Lambda表达式实现接口</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l5</span> <span class="hljs-operator">=</span> () -&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 5&quot;</span>);<br>        &#125;;<br>        l5.love();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个函数式接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILove</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//外部实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lover1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出为：</span><br>I love you my lover ---&gt; <span class="hljs-number">1</span><br>I love you my lover ---&gt; <span class="hljs-number">2</span><br>I love you my lover ---&gt; <span class="hljs-number">3</span><br>I love you my lover ---&gt; <span class="hljs-number">4</span><br>I love you my lover ---&gt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="关于Lambda表达式的更加极致的简化（针对有参数的Lambda表达书）"><a href="#关于Lambda表达式的更加极致的简化（针对有参数的Lambda表达书）" class="headerlink" title="关于Lambda表达式的更加极致的简化（针对有参数的Lambda表达书）"></a>关于Lambda表达式的更加极致的简化（针对有参数的Lambda表达书）</h3><ul><li><strong>简化数据类型</strong>  在Lambda表达式中可以将参数的数据类型省略，只留下一个数据名称。比较特殊的是如果有多个参数，省略的时候应该将所有参数的数据类型都省略，不然就全部不省略，而且需要用括号将参数包含在内。</li><li><strong>省略括号</strong> 参照上一条，只有一个参数要求的时候才可以省略括号</li><li><strong>省略花括号</strong> 在Lambda表达式中，只有当输出语句或者代码只有一行的时候可以省略花括号。假如有多条执行代码，还是需要用花括号将代码包含在内</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown语法的学习</title>
    <link href="/2022/09/01/markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/09/01/markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown语法的学习"><a href="#MarkDown语法的学习" class="headerlink" title="MarkDown语法的学习"></a>MarkDown语法的学习</h1><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>​设置标题方法是在前面加#号，一级标题（最大）是加#+空格 ，二级标题是加##+空格，之后的以此类推。</p><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><em>在文本的前后分别加上一个星号表示斜体字</em></p><p><strong>在文本的前后分别加上两个星号表示字体加粗</strong></p><p><em><strong>在文本的前后分别加上三个星号表示斜体加粗</strong></em></p><p><del>在文本的前后分别加上两个波浪线</del></p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>在文本的开头加上 &gt; 表示文本引用。一般用于引用他人的文章或是博客</p></blockquote><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>连续三个 — 表示一道分割线</p><p>也可以用连续三个 *** 表示一道分割线</p><hr><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p><img src="C:\Users\Thales\Desktop\111.png" alt="插入图片举例"></p><p><strong>输入一个！以及在中括号输入插入图片的名称，再在后面的小括号中选择插入的本地图片即可（这是针对本地图片插入的例子）</strong></p><hr><p>![在线图片举例](<a href="http://inews.gtimg.com/newsapp_match/0/12014684244/0.jpg&amp;refer=http://inews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg">http://inews.gtimg.com/newsapp_match/0/12014684244/0.jpg&amp;refer=http://inews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg</a> (1080×1350) (baidu.com)](<a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_match%2F0%2F12014684244%2F0.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638095138&amp;t=85d422240312fcf57a528b5c153c2de4">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_match%2F0%2F12014684244%2F0.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638095138&amp;t=85d422240312fcf57a528b5c153c2de4</a>))</p><p><strong>对于在线图片的插入，语法上是没有改变，不过需要注意的是在后面小括号中需要复制黏贴上在线图片的源码，或者说图片的在线位置(具体方法是在网页右键后选择查看，在里面查看)</strong></p><p><img src="C:\Users\Thales\Desktop\222.png" alt="在线图片源码"></p><p><em>上面就是在线图片的源码示例</em></p><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><strong>超链接</strong>可以在文章中插入一个<em>可以点击的按钮</em>，点击后就可以跳转到设置好的网站</p><p><em><strong>具体语法是输入一个半角的中括号，在中括号中设置超链接的名字，后面输入一个半角的小括号，在小括号中输入想要跳转的网站</strong></em></p><p>[例如现在点击这个超链接就可以转到我的博客](<a href="https://www.cnblogs.com/ZeeWay/">Thales_ZeeWay - 博客园 (cnblogs.com)</a>)</p><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ol><li><em>有序排列</em>，<em><strong>语法是输入1.+空格</strong></em>，就可以自动生成有序排列</li><li><em>后续排序直接回车键就可以</em></li></ol><ul><li><em>这是无序排列</em>，<em><strong>语法是输入- + 空格</strong></em> ，一样可以自动的生成</li></ul><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><em>生成列表的最简单也是最方便的方式就是右键选择插入列表即可</em></p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><em><strong>代码块的语法是 &#96;&#96;&#96; + 输入代码所属的语言</strong></em></p><p><em>下面例子就是以Java为例</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    System.out.print(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125; <br></code></pre></td></tr></table></figure><p><em>“本站所有文章均为原创，欢迎转载，请注明文章出处：<a href="https://www.cnblogs.com/ZeeWay/p/15481997.html">MarkDown学习随笔 - Thales_ZeeWay - 博客园 (cnblogs.com)</a>)。百度和各类采集站皆不可信，搜索请谨慎鉴别。技术类文章一般都有时效性，本人习惯不定期对自己的博文进行修正和更新，因此请访问出处以查看本文的最新版本。”</em></p><p><em>作者：Thales_ZeeWay<br>链接：<a href="https://www.cnblogs.com/ZeeWay/p/15481997.html">原文链接</a><br>来源：博客园</em><br><em><strong>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong></em></p>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的生命历程</title>
    <link href="/2022/09/01/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
    <url>/2022/09/01/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="线程的生命历程"><a href="#线程的生命历程" class="headerlink" title="线程的生命历程"></a>线程的生命历程</h1><h2 id="线程的五大状态"><a href="#线程的五大状态" class="headerlink" title="线程的五大状态"></a><em>线程的五大状态</em></h2><ul><li><strong>创建状态</strong>：简而言之，当创建线程对象的代码出现的时候，此时线程就进入了创建状态。这时候的线程只是行代码而已。<em>只有调用线程的start（）方法时，线程的状态才会改变，进入就绪状态</em></li><li><strong>就绪状态</strong>：在这个状态下的线程，<strong>已经做好了随时运行的准备，但是并不意味着会立刻开始运行。</strong>还需要等待CPU的<em>随机调度，随机运行</em>。<em>只有当线程被CPU调度运行成功</em>，此时的线程才算是进入下一个状态——运行状态。</li><li><strong>运行状态</strong>：线程处于运行状态，主要是在运行线程中的代码块。</li><li><strong>阻塞状态</strong>：在线程运行过程中，当线程代码块中调用了线程的sleep（），yield（），同步锁定或者其他使线程阻塞的方法，此时的线程无法继续运行下去，进入了阻塞状态（线程代码块的自身逻辑混乱也可以使线程阻塞）。<strong>当造成线程阻塞的阻塞事件解决之后，线程不会回到运行状态，而是回到就绪状态，再次等待CPU的调度运行。</strong>需要注意的是，<em><strong>阻塞并不意味着线程运行终止</strong></em></li><li><strong>死亡状态</strong>：<em>当线程成功运行完所有的代码之后，线程就结束了，也进入了死亡状态。线程一旦死亡，就无法再次启动</em>，注意这里和阻塞状态的不同。<em>同样的，当线程运行一半的时候被强行结束终止，也算进入死亡状态，也无法被再次启动。</em></li></ul><h2 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h2><p>Java中的thread类自带有线程的一些方法，这些方法可以让线程睡眠，插队，提高线程调度的优先级等等，它们提供了改变线程状态的操作手段。(不过在JDK帮助文档中，一些方法已经不推荐使用)</p><h3 id="线程方法中的一些有趣的地方"><a href="#线程方法中的一些有趣的地方" class="headerlink" title="线程方法中的一些有趣的地方"></a>线程方法中的一些有趣的地方</h3><ul><li><p>线程睡眠是以毫秒为单位的。一秒等于一千毫秒。一般在测试程序中调用睡眠方法，是为了提高程序问题的发生性，或者说为了发现bug</p></li><li><p>线程停止，由于Java中自带的停止方法不太好用，所以一般都是自己写一个停止的方法，标定一个布尔类型的Flag作为线程执行的标志，当flag为真时线程运行，当flag为假时线程停止。</p></li><li><p>线程礼让是将正在运行的线程暂停回到就绪状态，而不是变为阻塞状态。有趣的是礼让不是一定会成功的，因为线程由就绪状态进入运行状态是由CPU随机调度的。所以礼让的线程有可能在下次的调度中再次提前调度，提前运行。</p></li><li><p>线程插队（join方法），强制阻塞其他线程，只有插入的线程执行完成之后，其他线程才能继续执行</p></li><li><p>线程虽然有优先级的区别（1-10），但是在实际运行中还是得看CPU的心情调度运行，优先级高只是被调度的概率高一点。Java中自带有线程优先级的查看和改变方法（线程的优先级设置最好在线程启动之前）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ttp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//主线程的默认优先级</span><br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;---&gt;&quot;</span> + Thread.currentThread().getPriority());<br>        <span class="hljs-type">MyPriorty</span> <span class="hljs-variable">mm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPriorty</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mm);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mm);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mm);<br><br><br>        <br>        t1.setPriority(<span class="hljs-number">10</span>);<br>        t1.start();<br><br>        t2.setPriority(<span class="hljs-number">4</span>);<br>        t2.start();<br><br>        t3.setPriority(<span class="hljs-number">6</span>);<br>        t3.start();<br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Runnable接口实现接口，run方法为打印线程名称和线程的优先级</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPriorty</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;---&gt;&quot;</span> + Thread.currentThread().getPriority());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//这里的输出有多种结果，因为优先级只是增加了线程被调度运行的机率</span><br></code></pre></td></tr></table></figure></li><li><p>用户线程和守护线程。守护线程的作用是保证用户线程的执行过程正常，例如Java中的内存回收线程和后台记录操作日志等等，这些都是守护线程。虚拟机必须等待用户线程执行完毕，不用等待守护线程执行完毕。当用户线程完成后，虚拟机就自动关闭，守护线程也就自动死亡了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//Java的Thread类自带设置守护线程的方法</span><br>Thread.setdaemon(<span class="hljs-literal">true</span>) <span class="hljs-comment">//设置为守护线程</span><br><span class="hljs-comment">//一般我们创建的线程默认都是用户线程</span><br></code></pre></td></tr></table></figure></li><li><p>线程同步。<strong>线程同步是出现多个线程访问同一个对象并都想对其进行操作的时候必须考虑的问题</strong>。不进行线程同步（并发）控制的多线程是不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-comment">//线程不安全，出现了-1张票以及有两个线程拿到同一张票的错误，所以这是一个不安全的线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test05</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">buyTicket</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">buyTicket</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b1,<span class="hljs-string">&quot;you&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b1,<span class="hljs-string">&quot;i&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b1,<span class="hljs-string">&quot;he&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b1,<span class="hljs-string">&quot;she&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        t4.start();<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">buyTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-comment">//剩余票数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            buy();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(ticketNums &lt;= <span class="hljs-number">0</span>)&#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;买到了第&quot;</span> + ticketNums-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程同步实质上是一个等待机制。线程同步时会将多个线程放入对象等待池中进行排队（队列），等待前一个线程执行操作完毕，再有下一个线程进行执行操作。每个对象都有一个独有的锁（排他锁），每个线程执行时都会获得对象的排他锁，这样只有获得锁的线程可以对对象进行操作，执行结束后排他锁被下一个线程获得。总结来说，线程同步的形成条件就是：队列+锁</p><p>线程同步也有一些存在的问题</p><ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li><li>在多线程竞争下，加锁，释放锁会导致较多的上下文切换和调度延时，引起性能问题</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题</li></ul><p>​</p></li></ul><p></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
