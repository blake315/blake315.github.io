<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring学习手记</title>
    <link href="/2022/12/31/Spring%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/"/>
    <url>/2022/12/31/Spring%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring学习手记"><a href="#Spring学习手记" class="headerlink" title="Spring学习手记"></a>Spring学习手记</h1><h2 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1.Spring简介"></a>1.Spring简介</h2><blockquote><p>Spring是一个轻量级框架，基础版只有2m大小。</p><p>Spring的核心特性就是可以用于开发任何Java程序，但是在Java EE平台上构建web应用是是需要扩展的。Spring的目标是使Java EE开发变得更加容易，通过启用基于POJO编程模型来促进良好的编程实践。</p></blockquote><p>Spring家族中有很多适用于不同场景的框架，其中基础的是Spring Framework，基本上所有其他Spring框架都是建立在Spring Framework之上的。</p><p><a href="https://spring.io/projects">Spring家族</a></p><hr><p><strong>Spring Framework五大功能模块</strong></p><table><thead><tr><th>功能模块</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td>Core Container</td><td align="left">核心容器，在Spring环境下使用任何功能都必须基于IOC容器</td></tr><tr><td>AOP &amp; Aspects</td><td align="left">面向切面编程</td></tr><tr><td>Testing</td><td align="left">提供Junit&#x2F;Test NG测试框架的整合</td></tr><tr><td>Data Access&#x2F;Integeration</td><td align="left">提供了对数据访问&#x2F;集成的功能（SpringJDBC）</td></tr><tr><td>Spring MVC</td><td align="left">提供了面向Web应用程序的集成功能</td></tr></tbody></table><p><strong>Spring Framework特性</strong></p><ul><li>非侵入性：对原生技术和领域模型是零污染的</li><li><strong>控制反转</strong> <strong>IOC</strong>：反转资源获取方向，将自己创建资源，向环境索取资源转变为环境准备好资源，我们享受使用，降低对象与对象之间的依赖。</li><li><strong>面向切面</strong> <strong>AOP</strong>：在不修改代码的基础上，将容器内对象替换为代理类，再完成注入，增强代码功能。</li><li>容器：SpringIOC是一个容器，包含且管理组件的生命周期。组件享受容器化的管理，为程序员屏蔽组件创建过程中的大量细节，降低使用门槛。</li><li>声明式：之前需要编写代码才能实现的功能，现在只要声明需求即可由框架实现。</li><li>组件化：也就是放在容器中的bean，并且使用注入完整组件的组装。</li><li>一站式：在自身的基础之上可以整合各种企业应用的开源框架和优秀地方库，此外Spring家族系列覆盖了广泛的领域，很多方面的功能性需求都可以在Spring Framework的基础上全部使用Spring来实现。</li></ul><hr><h2 id="2-IOC"><a href="#2-IOC" class="headerlink" title="2.IOC"></a>2.IOC</h2><h3 id="2-1-IOC容器"><a href="#2-1-IOC容器" class="headerlink" title="2.1 IOC容器"></a>2.1 IOC容器</h3><p><strong>IOC是一种反转控制的思想，而DI是IOC的一种具体实现。</strong></p><blockquote><p>以前：需要使用什么资源需要自己创建，创建的细节也需要自己了解。</p><p>现在：现在需要使用什么资源，声明即可，IOC会自动向声明位置注入资源。（容器会推送资源给需要的组件，里面也会自动提供资源的创建方式，不需要自己处理）</p><p>DI：依赖注入，是IOC的另外一种表述方式，是IOC的具体实现。</p></blockquote><p>在实际上，IOC容器负责实例化，配置和组装对象。IOC容器从XML文件中获取信息并执行相应的工作。所以，IOC容器的主要任务就是：</p><ul><li>实例化应用程序类</li><li>配置对象</li><li>组装对象之间的依赖关系</li></ul><hr><h3 id="2-2-IOC在Spring中的实现"><a href="#2-2-IOC在Spring中的实现" class="headerlink" title="2.2 IOC在Spring中的实现"></a>2.2 IOC在Spring中的实现</h3><p>Spring中实现IOC主要有两种方式：</p><ul><li>BeanFactory，这是IOC的基本实现。而且是Spring内部使用的接口，面向Spring本身，并不提供给开发人员使用。</li><li>ApplicationContext，这是BeanFactory的子接口，提供了更多的高级他姓。面向的是使用者，几乎所有场景都使用ApplicationContext，而不是更加底层的BeanFactory。在这个子接口中，子类ClassPathXmlApplicationContext是使用最多的。</li></ul><hr><h2 id="3-基于XML管理Bean"><a href="#3-基于XML管理Bean" class="headerlink" title="3. 基于XML管理Bean"></a>3. 基于XML管理Bean</h2><blockquote><p>虽然现在有很多的注解可以用来更加简单的管理Bean，但是使用XML方式管理Bean依旧重要，当我们使用自己注入的类库组件时，是没办法使用注解的，所以只能使用XML方式来管理。</p></blockquote><h3 id="3-1-项目搭建与注册Bean"><a href="#3-1-项目搭建与注册Bean" class="headerlink" title="3.1 项目搭建与注册Bean"></a>3.1 项目搭建与注册Bean</h3><p>此部分需要实际操作，可以观看原视频中对应部分进行理解学习。</p><hr><h3 id="3-2-获取Bean的三种方式"><a href="#3-2-获取Bean的三种方式" class="headerlink" title="3.2 获取Bean的三种方式"></a>3.2 获取Bean的三种方式</h3><p>在IOC容器中提供的获取Bean方法一共有三种：</p><ul><li>根据id获取bean：根据配置文件中配置的bean id 属性进行获取。不过由于记忆id，所以较为少用</li><li>根据类型获取bean：要注意，如果配置文件中有多个相同类型的bean时，就会抛出NoUniqueBeanDefinitionException，&#x3D;&#x3D;也是实际开发开发中最常用的&#x3D;&#x3D;</li><li>根据id和类型获取bean：就是前两者的结合用法</li></ul><p><strong>如果组件实现了接口，同样可以使用接口的类型获取组件，但前提是Bean唯一</strong>。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Student implements Person</span><br><span class="hljs-comment">// &lt;bean id=&quot;student&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt;&lt;/bean&gt;</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> ioc.getBean(Person.class);<br></code></pre></td></tr></table></figure><hr><h3 id="3-3-依赖注入"><a href="#3-3-依赖注入" class="headerlink" title="3.3 依赖注入"></a>3.3 依赖注入</h3><h4 id="3-3-1-setter注入"><a href="#3-3-1-setter注入" class="headerlink" title="3.3.1 setter注入"></a>3.3.1 setter注入</h4><p>顾名思义，setter注入和实体类中的set方法有关，但是和成员变量没关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- setter 注入 和 set方法有关，跟成员变量没有关系--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-3-2-使用构造器中注入"><a href="#3-3-2-使用构造器中注入" class="headerlink" title="3.3.2 使用构造器中注入"></a>3.3.2 使用构造器中注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- public Student(Integer sid, String sname, Integer age, String gender) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentTwo&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里会根据<constructor-arg>标签的顺序来决定具体调用哪一个构造函数，和name属性没有关系，name属性的作用主要是用来告诉程序员对应的变量名称而已（name属性可以省略，不过因为代码可读性的要求，最好不要省略）</p><h4 id="3-3-3-其他类型的注入方式"><a href="#3-3-3-其他类型的注入方式" class="headerlink" title="3.3.3 其他类型的注入方式"></a>3.3.3 其他类型的注入方式</h4><h5 id="字面量注入"><a href="#字面量注入" class="headerlink" title="字面量注入"></a>字面量注入</h5><p>字面量包含基本数据类型以及对应的包装类型，还有String</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Xml"><span class="hljs-comment">&lt;!-- 为String类型赋值null使用null标签 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sname&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">null</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">null</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 对于特殊字符，可以使用转义，不过最常使用的哈斯hiCDATA区 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sname&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>&lt;![CDATA[ a&gt;b ]]&lt;/value&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure><h5 id="为类or接口类型的属性注入"><a href="#为类or接口类型的属性注入" class="headerlink" title="为类or接口类型的属性注入"></a>为类or接口类型的属性注入</h5><p><strong>第一种方式是使用ref属性设置。这种注入方式，在IOC容器中有两个bean，分别hi是courseOne和studentOne，且都可以正常获取。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;courseOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Course&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注入省略 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- void setCourse(Course course) --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;course&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;courseOne&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>第二种方式是使用内部bean的方式注入。和第一种注入方式的区别在于：IOC容器无法获取到内部Bean。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- void setCourse(Course course) --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;course&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;courseOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Course&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cid&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2222&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;远大前程班&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="数组类型注入"><a href="#数组类型注入" class="headerlink" title="数组类型注入"></a>数组类型注入</h5><p>使用<array>标签实现注入。数组中的元素如果是字面量数据，就使用value标签赋值；如果是类类型，就是用ref标签赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- String[] hobby; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>抽烟<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>喝酒<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>烫头<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <br>            <span class="hljs-comment">&lt;!-- 类类型用 --&gt;</span><br>            <span class="hljs-comment">&lt;!-- &lt;ref bean=&quot;id&quot;&gt;&lt;/ref&gt; --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="List注入（两种方法）"><a href="#List注入（两种方法）" class="headerlink" title="List注入（两种方法）"></a>List注入（两种方法）</h5><ol><li><p>在Property标签内部设置，字面量使用value标签，类类型使用ref标签。（和数组注入类似）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;course&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Course&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- List&lt;Student&gt; students --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;students&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;studentOne&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;studentTwo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;studentThree&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>从List类型的bean中注入，首先需要配置一个List的bean，之后通过ref属性注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;course&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Course&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- List&lt;Student&gt; students --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;studentList&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置一个集合类型的bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentList&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;studentOne&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;studentTwo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="Map注入"><a href="#Map注入" class="headerlink" title="Map注入"></a>Map注入</h5><ol><li><p>和List注入类似，也是在Property标签内部设置，如果键是字面量类型使用key属性，是类类型就使用key-ref</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacherOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Teacher&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacherTwo&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Teacher&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Map&lt;String, Teacher&gt; teacherMap; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacherMap&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;teacherOne&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;teacherOne&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;teacherTwo&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;teacherTwo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>直接从Map类型的bean注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">util:map</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacherMap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;teacherOne&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;TeacherOne&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;teacherTwo&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;teacherTwo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">util:map</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Map&lt;String, Teacher&gt; teacherMap; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacherMap&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;teacherMap&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="3-4-Bean的作用域"><a href="#3-4-Bean的作用域" class="headerlink" title="3.4 Bean的作用域"></a>3.4 Bean的作用域</h3><p><strong>scope&#x3D;“single|prototype”</strong></p><p>在bean中使用scope属性设置Bean的作用域。single表示使用单例模式，也是默认设置，获取bean所对应的对象都是同一个。prototype表示使用原型，也就是多例，获取bean所对应对象不是同一个。</p><p>另外，在WebApplicationContext环境下还有另外两个作用域：requst和session，分别表示在一次请求和一次会话中有效。</p><hr><h3 id="3-5-Bean的生命周期"><a href="#3-5-Bean的生命周期" class="headerlink" title="3.5 Bean的生命周期"></a>3.5 Bean的生命周期</h3><p>具体的生命周期如下：</p><ul><li>实例化，使用工厂模式和反射实现</li><li>依赖注入</li><li>初始化，需要在bean标签中使用init-method属性指定初始化方法</li><li>销毁，需要注意的时候，当IOC容器关闭之后Bean才会执行销毁方法，而且和初始化一样，需要在bean标签中使用destory-method属性指定销毁方法</li></ul><p>注意：如果bean的作用域是单例的，生命周期的前三个步骤会在获取IOC容器的时候就执行；如果bean的作用域是多例的，那么生命周期的前三个步骤会在回去调用bean的时候才执行。</p><p>bean的后置处理器，它主要是bean初始化前后添加额外的操作。需要实现BeanPostProcessor接口且配置到IOC容器之中，要注意，bean后置处理器不是单独针对一个bean生效的，而是针对IOC容器中所有bean都会执行。</p><hr><h3 id="3-6-FactoryBean（了解会使用即可）"><a href="#3-6-FactoryBean（了解会使用即可）" class="headerlink" title="3.6 FactoryBean（了解会使用即可）"></a>3.6 FactoryBean（了解会使用即可）</h3><p>FactoryBean是Spring提供的一种整合第三方框架的机制。配置一个FactoryBean类型的bean之后，在获取bean对象获取的不是class属性中配置的这个类的对象，而是getObject方法的返回值。通过这种机制，Spring可以把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示出来。</p><p>其中有三个方法</p><ul><li>getObject：通过一个对象交给IOC容器进行管理</li><li>getObjectType：设置提供对象的类型</li><li>isSingleton：所提供的对象是否是对象的</li></ul><hr><h3 id="3-7-基于XML的自动装配"><a href="#3-7-基于XML的自动装配" class="headerlink" title="3.7 基于XML的自动装配"></a>3.7 基于XML的自动装配</h3><blockquote><p>自动装配：根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型赋值。</p><p>说人话就是在为类类型（或者接口类型）注入的时候，在XML文件中不需要再写property标签和ref标签，而是由Spring为我们自动注入装配。</p></blockquote><p>在bean标签中设置autowire属性，来设置不同的配置策略</p><ul><li>no|default：默认，就是不装配。</li><li>byName：根据要配置的属性名，在bean中寻找到id和属性名相匹配的自动装癖。当容器当中有多个相同类型能匹配到的时候，可以使用byName进行区分，实现自动装配。</li><li>byType：根据类型，在bean中寻找匹配类型的bean自动装配，这也是使用最多的方式。需要注意，如果找不到合适类型的bean就不装配，如果找到多个则会抛出异常：noUniqueBeanDefinitionException</li></ul><hr><h2 id="4-基于注解管理Bean"><a href="#4-基于注解管理Bean" class="headerlink" title="4. 基于注解管理Bean"></a>4. 基于注解管理Bean</h2><blockquote><p>和XML配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体功能是由框架检测到注解标记的位置，然后针对这个位置按照注解标记的内容来执行具体的操作</p><p>在Spring中，基于注解管理bean分为标记和扫描两个部分，标记就是在需要的地方添加注解，之后需要通过扫描的方式来检测，之后根据注解进行后续的操作。</p></blockquote><p>使用注解管理Bean或者使用XML管理Bean，两者本质上所有的操作都是Java代码来完成的，XML和注解的作用只是告诉框架中的Java代码如何执行。</p><h3 id="4-1-四个基础注解"><a href="#4-1-四个基础注解" class="headerlink" title="4.1 四个基础注解"></a>4.1 四个基础注解</h3><ul><li>@Component：将类标识为普通组件</li><li>@Controller：将类标识为控制层组件</li><li>@Service：将类标识为业务层组件</li><li>@Repository：将类标识为持久层组件</li></ul><p>&#x3D;&#x3D;其实对于Spring来说，后三个注解的含义和第一个注解的含义并你没有什么区别。，后三个注解只不过是在@Component的基础之上另外取的三个名字。&#x3D;&#x3D;</p><p>对于bean的id，在注解中不写的默认情况之下是小驼峰，就比如UserController加上注解之后，它在容器中的id就是<code>userController</code></p><p>当然也可以自定义id，例如<code>@Controller(&quot;userController&quot;)</code></p><h3 id="4-2-扫描组件"><a href="#4-2-扫描组件" class="headerlink" title="4.2 扫描组件"></a>4.2 扫描组件</h3><hr><h2 id="5-AOP"><a href="#5-AOP" class="headerlink" title="5. AOP"></a>5. AOP</h2><h3 id="5-1-场景模拟，提出问题"><a href="#5-1-场景模拟，提出问题" class="headerlink" title="5.1 场景模拟，提出问题"></a>5.1 场景模拟，提出问题</h3><p><strong>在上面的场景模拟中，我们可以提出以下的问题</strong>：</p><ul><li>现有代码缺陷。在针对于带有日志功能的实现类，我们发现有如下的缺陷：<ul><li>对核心业务功能有干扰，导致程序员在开发核心业务功能时分散精力</li><li>附加功能分散在各个业务功能方法之间，不利于统一维护</li></ul></li></ul><p><strong>解决这两个问题的思路的核心就在于：解耦。我们要把附加功能从业务功能中抽取出来、</strong></p><p><strong>但是解决问题也存在相对应的困难：因为要抽取的代码在方法内部，依靠之前把子类中的重复代码抽取到父类的方法是无法解决的（抽取封装只能将一段连续执行的代码抽取，无无法解决这里的问题）。因此需要使用新的技术：代理模式</strong></p><h3 id="5-2-代理模式"><a href="#5-2-代理模式" class="headerlink" title="5.2 代理模式"></a>5.2 代理模式</h3><p><strong>代理模式</strong>是二十三种设计模式的一种，属于结构型模式。主要作用是通过一个代理类对象，使得在调用目标方法时不是直接对目标方法进行调用，而是使用代理类对象间接调用，<strong>使不属于目标方法核心逻辑的代码从目标方法种剥离解耦</strong>，调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰、同时让附加功能能够集中在一起且方便统一维护。</p><blockquote><p>说人话，我理解的代理模式就是：发现代码是不连续，没办法抽取封装到父类中。那么我就不抽取两边不连续的代码了嘛，直接抽取中间的核心连续代码，之后使用另外一个类来完成需求，在对应方法里面调用对应的方法。</p></blockquote><p>在代理模式中，分为静态代理和动态代理两种</p><h4 id="5-2-1-静态代理"><a href="#5-2-1-静态代理" class="headerlink" title="5.2.1 静态代理"></a>5.2.1 静态代理</h4><p>特点是一对一，也就是一个代理类对应一个目标类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorStaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">calculator</span>&#123;<br><br>    <span class="hljs-comment">//将目标对象声明为成员变量</span><br>    <span class="hljs-keyword">private</span> CalculatorImpl target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CalculatorStaticProxy</span><span class="hljs-params">(CalculatorImpl target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><span class="hljs-comment">//之后在方法中调用目标对象的核心代码</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;日志，方法：add， 参数：&quot;</span> + i + <span class="hljs-string">&quot;, &quot;</span> + j);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> target.add(i , j);<br>        System.out.println(<span class="hljs-string">&quot;日志，方法：add， 结果：&quot;</span> + res);<br>        <span class="hljs-keyword">return</span> res ;<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这样来看，静态代理确实解决了我们上面的问题。但是由于代码都写死了，完全不具备任何的灵活性。如果后续还需要附加日志的话，是不是还得声明更多的代理类？如此一来的话，也会产生大量的冗余代码，日志功能还是分散的，没办法统一管理。</p><p>由此进一步提出需求：将日志功能集中到一个代理类中，如果之后还有任何日志需求，都可以通过这一个代理类来实现。这就需要需用来进一步的代理模式；动态代理了。</p></blockquote><h4 id="5-2-2-动态代理"><a href="#5-2-2-动态代理" class="headerlink" title="5.2.2 动态代理"></a>5.2.2 动态代理</h4><p>核心实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyFactory</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数介绍：</span><br><span class="hljs-comment">         * ClassLoader loader：指定加载动态生成的代理类的类加载器</span><br><span class="hljs-comment">         * Class[] interfaces：获取目标对象实现的所有接口的class对象数组</span><br><span class="hljs-comment">         * InvocationHandler h：设置代理类中的抽象方法如何重写</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader();<br>        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object o, Method method, Object[] objects)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                System.out.println(<span class="hljs-string">&quot;日志，方法：&quot;</span> + method.getName() + <span class="hljs-string">&quot;参数&quot;</span> + Arrays.toString(objects));<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> method.invoke(target, objects);<br>                System.out.println(<span class="hljs-string">&quot;日志，方法；&quot;</span> + method.getName() + <span class="hljs-string">&quot;结果：&quot;</span> + res);<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后编写测试代码如下；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStaticProxy</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">proxyFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CalculatorImpl</span>());<br>    <span class="hljs-comment">//这里使用向上转型，才可以调用对应的核心方法</span><br>    <span class="hljs-type">calculator</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (calculator) proxyFactory.getProxy();<br>    proxy.add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>动态代理有两种；JDK动态代理，cglib动态代理。</p><ol><li>JDK动态代理：要求必须有接口，最后生成的代理类和目标类实现相同的接口在<code>com.sun.proxy</code>下，类名为<code>$proxy2</code></li><li>cglib动态代理；最终生成的代理类会继承目标类，并且和目标类在相同的包下</li></ol><hr><h3 id="5-3-AOP概念和术语"><a href="#5-3-AOP概念和术语" class="headerlink" title="5.3 AOP概念和术语"></a>5.3 AOP概念和术语</h3><p><strong>AOP（Aspect Oriented Progarmming）是一种设计思想，是软件设计领域中的面向切面设计，他是面向对象编程的一种补充和完善，它以通过预编译的方式和运行期动态代理的方式实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术。</strong></p><p>它具体由以下几个作用：</p><ul><li>简化代码</li><li>代码增强</li></ul><h4 id="5-3-1-术语概念"><a href="#5-3-1-术语概念" class="headerlink" title="5.3.1 术语概念"></a>5.3.1 术语概念</h4><ol><li>横切关注点：就是从每个方法最终抽取出来的同一类非核心业务。是根据附加功能的逻辑需要抽取的</li><li>通知：在每个横切关注点上要做的事情都需要写一个方法来实现，这就是通知，根据不同的执行时期，可以分为：<ol><li>前置通知：在被代理的目标方法之前执行</li><li>返回通知：在被代理的目标方法成功结束后执行</li><li>异常通知：在被代理的目标方法异常结束后执行</li><li>后置通知：在被代理的目标方法最终结束后执行</li><li>环绕通知，使用<code>try...catch...finally</code>结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li></ol></li><li>切面：就是封装通知方法的类。</li><li>目标：也就是被代理的目标对象</li><li>代理：向目标对象应用通知之后创建的代理对象</li><li>连接点：是纯逻辑概念，可以理解为抽取横切关注点的位置或者抽取代码的地方</li><li>切入点：定位连接点的方式，是连接点的具体实现</li></ol><hr><h3 id="5-4-基于注解的AOP"><a href="#5-4-基于注解的AOP" class="headerlink" title="5.4 基于注解的AOP"></a>5.4 基于注解的AOP</h3><p><em>准备工作可以看原视频</em></p><hr><h2 id="6-jdbcTemplate"><a href="#6-jdbcTemplate" class="headerlink" title="6.jdbcTemplate"></a>6.jdbcTemplate</h2><p>其实就是Spring中基于jdbc封装的用来操作数据库的方法而已。了解操作即可，因为后续项目的学习都是基于Spring整合MyBatis来操作数据库，对于jdbcTemplate的使用其实不多，而且其实操作数据库的方法API大多都大同小异，需要使用时候返回来查看即可。</p><hr><h2 id="7-声明式事务"><a href="#7-声明式事务" class="headerlink" title="7. 声明式事务"></a>7. 声明式事务</h2><h3 id="7-1-编程式事务"><a href="#7-1-编程式事务" class="headerlink" title="7.1 编程式事务"></a>7.1 编程式事务</h3><p>顾名思义，就是事务功能的相关操作全部都由自己编写代码完成，例如开启事务，提交事务，回滚事务和释放数据库连接。可想而知，这种粗略的方式必定存在缺陷：</p><ul><li>细节没有被屏蔽：具体操作过程中，所有的细节都需要程序员自己完成，十分的麻烦</li><li>代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用</li></ul><h3 id="7-2-声明式事务"><a href="#7-2-声明式事务" class="headerlink" title="7.2 声明式事务"></a>7.2 声明式事务</h3><p>因为事务控制的代码是有规律的，其代码结构基本也是确定的，所以框架就可以将固定模式的代码抽取，进行相关的封装。之后我们只需要在配置文件中进行简单的配置即可完成操作。它的好处有很多，比如：提高了开发效率，减少了冗余代码，框架的使用会考虑到各种问题所以对应会对代码的健壮性，性能等各个方面都会得到优化</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis学习手记</title>
    <link href="/2022/12/31/MyBatis%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/"/>
    <url>/2022/12/31/MyBatis%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis学习笔记"><a href="#MyBatis学习笔记" class="headerlink" title="MyBatis学习笔记"></a>MyBatis学习笔记</h1><blockquote><p>基于教程or博客：</p><p><a href="https://www.bilibili.com/video/BV1Ya411S7aT/?spm_id_from=333.337.search-card.all.click">【尚硅谷】SSM框架教程</a></p><p><a href="https://wuhang.xyz/c460cf59.html">MyBatis学习笔记—-Matty‘s Blog</a></p><p>本机环境：</p><ul><li>IDEA 2021.2.3</li><li>JDK 15</li><li>Maven 3.6.0</li><li>MySQL8</li><li>MyBatis 3.5.7</li></ul></blockquote><h2 id="1-简介介绍"><a href="#1-简介介绍" class="headerlink" title="1.简介介绍"></a>1.简介介绍</h2><p>在官方中文站上面是这么写的</p><blockquote><p>MyBatis 是一款优秀的&#x3D;&#x3D;持久层&#x3D;&#x3D;框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis &#x3D;&#x3D;免除&#x3D;&#x3D;了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以&#x3D;&#x3D;通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO&#x3D;&#x3D;（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><p>所谓持久层，简单言之就是将数据固定保存的一大坨代码。在电脑上有两个数据存储的地方，RAM（内存）和ROM（硬盘）。RAM中的数据是短暂的，当你关闭电脑之后这里面的数据就会消失。有时候我们想将数据在RAM中保存下来，就需要持久层发挥作用，将内容保存到ROM中，这样我们才可以长期获得相同的数据。</p><p>后面的，其实就是大概说明MyBatis是如何方便我们写SQL，操作数据库。</p><h3 id="1-1历史"><a href="#1-1历史" class="headerlink" title="1.1历史"></a>1.1历史</h3><p>MyBatis起源于Apache的一个开源项目ibatis。所以有的时候在导入包的时候，会发现包名是ibatis。</p><h3 id="1-2特点"><a href="#1-2特点" class="headerlink" title="1.2特点"></a>1.2特点</h3><ul><li>&#x3D;&#x3D;自定义SQL&#x3D;&#x3D;：就是可以按照自己的需求手写SQL语句。</li><li>&#x3D;&#x3D;支持存储过程&#x3D;&#x3D;</li><li>&#x3D;&#x3D;支持高级映射&#x3D;&#x3D;：可以自定义POJO和数据库字段之间的映射。</li></ul><h3 id="1-3对比其他持久层框架"><a href="#1-3对比其他持久层框架" class="headerlink" title="1.3对比其他持久层框架"></a>1.3对比其他持久层框架</h3><ul><li>JDBC：缺点是SQL是夹杂在JAVA文件中的，耦合度高，导致硬编码内伤。此外，对后期的维护不易，因为实际的开发需求中SQL发生变化，经常修改的情况非常多。最后是代码非常多，开发效率低下。</li><li>Hibernate和JPA：这两种虽然开发效率高，操作简便，但是由于是内部生成SQL语句，所以不容易对项目做出特殊的优化。另外由于反射操作过多，导致性能下降。而且两者都是基于全映射的全自动框架，大量字段的POJO进行部分映射的时候会比较困难。</li></ul><blockquote><p>不过，Hibernate和JPA在后续的发展过程中，据说在性能和操作方面已经是大幅度超过MyBatis了。在国外发起的开发框架投票中，JPA的使用者占到了一半以上，相比之下MyBatis只有百分之二十。不过在我学习的现在，国内主流框架还是MyBatis+一堆插件（比如MyBatis-plus）</p></blockquote><h2 id="2-快速开始-第一个MyBatis程序"><a href="#2-快速开始-第一个MyBatis程序" class="headerlink" title="2.快速开始-第一个MyBatis程序"></a>2.快速开始-第一个MyBatis程序</h2><h3 id="2-0-设计表以及添加数据"><a href="#2-0-设计表以及添加数据" class="headerlink" title="2.0 设计表以及添加数据"></a>2.0 设计表以及添加数据</h3><blockquote><p>因为设计表仅仅为了学习Mybatis，所以不需要太复杂，简单设计几个字段即可。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_user` (<br>  `id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `gender` <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `email` <span class="hljs-type">char</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">13</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb3;<br></code></pre></td></tr></table></figure><h3 id="2-1-创建Maven项目以及导入相关依赖"><a href="#2-1-创建Maven项目以及导入相关依赖" class="headerlink" title="2.1  创建Maven项目以及导入相关依赖"></a>2.1  创建Maven项目以及导入相关依赖</h3><p><em>这里如果没学过Maven的话，墙裂建议先去了解学习一下，非常非常好用。操作也十分简单，基本上两个小时就可以了解大概。之后就是在实际应用中不断使用加强记忆了。</em></p><p><strong>这里导入的依赖主要有四个，第一个是mybaits核心依赖，第二个是Junit测试依赖，第三个是MySQL依赖，第四个log4j日志依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- mybatis 核心 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- junit 测试 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- log4j --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>CV完之后，更新一下POM，稍等片刻，你就会发现学习MyBatis所需要的所有依赖都已自动下载好了！！（这么激动的原因是，以前都是手动导包。你大概也经历过，去网上搜索，下载的时候大概率还要忍受某度网盘的速度，而且更加绝望的是，你有可能最后发现你下载半天的jar包还和你的版本不匹配。）</p><p>导入之后先别急着进行下一步。这里先把主项目目录下的src文件删除。然后再新建一个Maven模块。这样，子pom会自动继承父pom的依赖，免去我们每次新建项目都要重新导入依赖的麻烦，此外还可以帮助我们更好的管理和编写代码。</p><h3 id="2-2-配置MyBatis核心文件"><a href="#2-2-配置MyBatis核心文件" class="headerlink" title="2.2  配置MyBatis核心文件"></a>2.2  配置MyBatis核心文件</h3><blockquote><p>配置文件都写在XML文件中，这里面包含了MyBatis系统的核心设置。比如获取数据库连接实例的数据源，决定事务作用域和控制方式的事务管理。</p></blockquote><p>创建完项目之后，需要在src&#x2F;main&#x2F;resources目录下面新建mybatis-config.xml文件。然后补充下面的内容。</p><p><em>在这里，我们习惯上命名为：mybatis-config.xml，并非强制。此外，这里的配置只是确保MyBatis可以运行的最小配置，详细配置和介绍在后续会提及。也可以在官方文档中找到详细的介绍。</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        配置链接数据库的环境</span><br><span class="hljs-comment">        default : 选择那个环境有效</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 事务管理器 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 数据源 即连接池--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://这里是本机数据库地址?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8amp;autoReconnect=true&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;用户名&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;密码&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 引入 MyBatis 的映射文件 : 存放SQL语句 和 POJO的映射方式</span><br><span class="hljs-comment"> 这个文件是后面再写的，这里可以先空着--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-UserMapper接口"><a href="#2-3-UserMapper接口" class="headerlink" title="2.3  UserMapper接口"></a>2.3  UserMapper接口</h3><blockquote><p>类似于DAO，不过不需要创建一个实现类。而是通过Mybatis来创建代理实现类，并执行映射文件中编写的SQL语句</p><p>习惯上的起名是 POJO+Mapper</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mybatis.mapper;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-UserMapper映射文件"><a href="#2-4-UserMapper映射文件" class="headerlink" title="2.4  UserMapper映射文件"></a>2.4  UserMapper映射文件</h3><p>接下来在resources文件下新建一个UserMapper.xml文件。在这个文件中，Mapper文件中的一个抽象方法，一一对应映射文件中的一条SQL语句。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- namespace ：对应的mapper接口 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        id : 对应接口的方法名称。一定要确保id和抽象方法一致，否则会报错</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>        INSERT INTO t_user VALUES (NULL, &#x27;admin&#x27;, &#x27;123456&#x27;, 23, &#x27;男&#x27;, &#x27;12345@qq.com&#x27;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-log4j配置文件"><a href="#2-5-log4j配置文件" class="headerlink" title="2.5  log4j配置文件"></a>2.5  log4j配置文件</h3><blockquote><p>这里的log4j配置文件，并非是MyBatis运行的必要条件。这里添加的原因是可以方便定位报错位置。</p><p>在log4j中有不同的日志级别：FATAL（致命） &gt; ERROR（错误） &gt; WARN（警告）&gt; INFO（信息） &gt; DEBUG（调试）</p><p>从左到右打印的内容会越来越详细</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">log4j</span>:configuration <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;log4j.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">log4j:configuration</span> <span class="hljs-attr">xmlns:log4j</span>=<span class="hljs-string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Encoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ConversionPattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%-5d %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.ibatis&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;info&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 默认配置，级别为debug 且根据name为log.console和 log.file两个appender输出--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">log4j:configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-6-测试功能"><a href="#2-6-测试功能" class="headerlink" title="2.6  测试功能"></a>2.6  测试功能</h3><p>最后，在test&#x2F;java中编写测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mybatis;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> com.atguigu.mybatis.mapper.UserMapper;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsert</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取核心配置文件的输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">resourceAsStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br><br>        <span class="hljs-comment">// 获取SqlSessionFactoryBuilder 对象 -&gt; 工厂构建器</span><br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br><br>        <span class="hljs-comment">// 创建 SqlSession 工厂 -&gt; 创建会话</span><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(resourceAsStream);<br><br>        <span class="hljs-comment">// 获取 会话 对象 -&gt; MyBatis 提供的操作数据库的对象</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><br>        <span class="hljs-comment">// 获得Mapper接口的代理类 -&gt; 操纵Mapper类执行数据库操作</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br><br>        <span class="hljs-comment">// 执行SQL操作</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> userMapper.insertUser();<br>        System.out.println(<span class="hljs-string">&quot;rows = &quot;</span> + rows);<br><br>        <span class="hljs-comment">// 提交事务 -&gt; 事务是默认开启的</span><br>        sqlSession.commit();<br><br>        <span class="hljs-comment">// 关闭资源</span><br>        sqlSession.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最后，刷新一下数据库，就可以在数据库中看到插入的数据了。</p><h2 id="3-初步了解核心配置文件"><a href="#3-初步了解核心配置文件" class="headerlink" title="3. 初步了解核心配置文件"></a>3. 初步了解核心配置文件</h2><h3 id="3-1-environments"><a href="#3-1-environments" class="headerlink" title="3.1 environments"></a>3.1 environments</h3><p>顾名思义，就医配置MyBatis当前工作数据库环境的的地方。需要注意这里的标签是复数的，也就是可以配置多个环境（environment），此时使用唯一的ID属性来区分不同的环境。</p><p>以我们上面配置的文件为例，复数标签中的default属性表示默认hi使用的环境ID。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 事务管理器 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 数据源 即连接池--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://这里是本机数据库地址?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8amp;autoReconnect=true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;用户名&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;密码&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-1-1-transactionManager"><a href="#3-1-1-transactionManager" class="headerlink" title="3.1.1 transactionManager"></a>3.1.1 transactionManager</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 事务管理器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里使用type属性来设置事务管理器的类型。</p><p>JDBC表示使用JDBC原生事务管理方式，可以手动的开启关闭事务，手动提交回滚事务。</p><p>MANAGED：被管理的，也就是其他的事务管理方式。例如可以使用Spring来管理事务。</p><h4 id="3-1-2-DataSource"><a href="#3-1-2-DataSource" class="headerlink" title="3.1.2 DataSource"></a>3.1.2 DataSource</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 数据源 即连接池--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://这里是本机数据库地址?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8amp;autoReconnect=true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;用户名&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;密码&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br></code></pre></td></tr></table></figure><p>主要作用是设置数据源，属性type就是数据源的类型，比如POOLED就是使用数据库连接池，还可以设置UNPOOLED（不使用数据库连接池，每个链接直接重新创建）和JNDI（使用上下文中的数据源）</p><p>其中的子标签都是配置标签，是用来配置连接数据库的相关信息。</p><h3 id="3-2-引入jdbc-properties"><a href="#3-2-引入jdbc-properties" class="headerlink" title="3.2 引入jdbc.properties"></a>3.2 引入jdbc.properties</h3><p>本质上就是将datasource中的配置信息提取，放在jdbc.properties文件中，如果需要使用，就直接在核心配置文件中引入即可直接使用。</p><blockquote><p>提取配置信息，在resources目录下新建文件jdbd.properties</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://192.168.23.128:3306/ssm?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf-8&amp;autoReconnect=true</span><br><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">jdbc.user</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><blockquote><p>引入文件，直接使用</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引入 properties 文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-3-typeAliases"><a href="#3-3-typeAliases" class="headerlink" title="3.3 typeAliases"></a>3.3 typeAliases</h3><p>类型别名，设置之后就可以在Mapper中的resultType属性中使用简单类型别名。</p><h3 id="3-4-settings"><a href="#3-4-settings" class="headerlink" title="3.4 settings"></a>3.4 settings</h3><p>是核心全局设置，常用的有下划线转驼峰，延迟加载等。其他的一些设置都可以在官方文档中找到。</p><h4 id="3-4-1-下划线转驼峰"><a href="#3-4-1-下划线转驼峰" class="headerlink" title="3.4.1 下划线转驼峰"></a>3.4.1 下划线转驼峰</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 下划线 自动映射 驼峰 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-4-2-延迟加载"><a href="#3-4-2-延迟加载" class="headerlink" title="3.4.2 延迟加载"></a>3.4.2 延迟加载</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 延迟加载</span><br><span class="hljs-comment">        LazyLoadingEnabled: true，开启延迟加载</span><br><span class="hljs-comment">        aggressiveLazyLoading: false, 开启按需加载</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;aggressiveLazyLoading&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-5-Mappers"><a href="#3-5-Mappers" class="headerlink" title="3.5 Mappers"></a>3.5 Mappers</h3><p>引入Mapper映射文件主要有两种方式，单个文件引入和包引入。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        包扫描方式, 两个条件</span><br><span class="hljs-comment">        1. Mapper 接口和 Mapper.xml 必须在一个包下</span><br><span class="hljs-comment">        2. Mapper 接口必须和 Mapper.xml 名字一致</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-不同类型参数的获取"><a href="#4-不同类型参数的获取" class="headerlink" title="4. 不同类型参数的获取"></a>4. 不同类型参数的获取</h2><p>在MyBatis中，获取输入参数的方式有两种，分别是 <strong>#()</strong> 和 <strong>$()</strong> 。两者的大致功能都类似，只不过在处理特殊场景时使用不同的方式会比较便捷。在实际使用中，最常使用的是**#{}**。</p><p>总的来说，获取参数的情况可以分为：获取单个字面量参数，获取多个字面量参数，获取单个POJO，以及Map等集合。 </p><h3 id="4-1-获取单个字面量参数"><a href="#4-1-获取单个字面量参数" class="headerlink" title="4.1 获取单个字面量参数"></a>4.1 获取单个字面量参数</h3><p>在MyBatis中获取单个参数的方法十分简单，只需要在sql语句中使用**#{}和${}**来表示参数即可。需要注意的是，前者使用的方式是占位符方式，后者使用的是字符串拼接的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserByUsername</span><span class="hljs-params">(String username)</span>;<br><span class="hljs-comment">//这里是mapper接口中的方法。</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 占位符方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE username = #&#123;username&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 字符串拼接方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE username = &#x27;$&#123;username&#125;&#x27;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="4-2-获取多个字面量参数"><a href="#4-2-获取多个字面量参数" class="headerlink" title="4.2 获取多个字面量参数"></a>4.2 获取多个字面量参数</h3><p><strong>当Mapper接口中的方法有多个参数的时候，MyBatis会创建Map，使用paramX或者argX为键，参数为值，在使用的时候就需要按照输出的参数顺序，获取需要的不同的参数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">User <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(String username, String password)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE username = #&#123;param1&#125; and password = #&#123;param2&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE username = #&#123;arg0&#125; and password = #&#123;arg1&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>因为使用paramX或argX需要记忆参数的位置，在实际开发中较为不便。因而现在常用的是在Mapper接口的方法参数前添加@Param（）注解，在注解中设置参数的别名（一般也就是参数名），这样就可以在XML文件直接使用参数名获取需要的参数了。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">User <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username, <span class="hljs-meta">@Param(&quot;password&quot;)</span> String password)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE username = #&#123;username&#125; and password = #&#123;password&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-3-获取单个POJO"><a href="#4-3-获取单个POJO" class="headerlink" title="4.3 获取单个POJO"></a>4.3 获取单个POJO</h3><blockquote><p>需要注意的是，POJO中必须有getter和setter方法，因为属性只跟getter&#x2F;setter有关系；单个POJO会形成一个Map，属性名作为键，getter后面的值作为值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(User user)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>insert into t_user values (null, #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;gender&#125;, #&#123;email&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-4-在Map中获取"><a href="#4-4-在Map中获取" class="headerlink" title="4.4 在Map中获取"></a>4.4 在Map中获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &#123;username: &quot;xxxx&quot;&#125;</span><br><span class="hljs-comment"> * &#123;password: &quot;xxxx&quot;&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>User <span class="hljs-title function_">checkLoginByMap</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Xml"><span class="hljs-comment">&lt;!-- User checkLoginByMap(Map&lt;String, Object&gt; map); --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLoginByMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE username = #&#123;username&#125; and password = #&#123;password&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h2><h3 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1.一级缓存"></a>1.一级缓存</h3><p>一级缓存是sqlSession级别的缓存。默认是自动开启的。从一个sqlSession中查询出来的数据会被缓存，当再一次在同一sqlSession中查询同一条记录时会直接从缓存中获取。</p><p>在以下情况中，一级缓存会失效：</p><ol><li>不同的sqlSession对应不同的一级缓存</li><li>同一个sqlSession但是查询条件不同</li><li>同一个sqlSession两次查询期间执行了任一增删改操作</li><li>同一个sqlSession两次查询期间手动清空了缓存</li></ol><h3 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2.二级缓存"></a>2.二级缓存</h3><p>二级缓存是sqlSessionFactory级别的缓存，需要手动开启。通过同一个sqlSessionFactory创建的sqlSession查询的结果会被缓存，之后如果再次执行同样的操作，会直接从缓存中获取数据。</p><p>二级缓存开启的条件：</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;“true”，默认为true，不需要设置。</li><li>在映射文件中设置标签cache</li><li>二级缓存必须在sqlSession关闭或者提交之后有效</li><li>查询的数据所转换的实体类型必须实现序列化接口</li></ol><p>二级缓存失效的条件：在两次查询之间执行了任一增删改操作。</p><h3 id="二级缓存的相关配置"><a href="#二级缓存的相关配置" class="headerlink" title="二级缓存的相关配置"></a>二级缓存的相关配置</h3><p>了解即可，暂时使用默认设置。</p><ul><li><p>eviction属性：缓存回收策略，默认是LRU</p></li><li><p>flushInterval属性：刷新间隔，默认不设置。</p></li><li><p>size属性：缓存最多可以存储多少个对象，过大会导致内存溢出。</p></li><li><p>readOnly属性：只读属性，有true和false两个值。</p><p>true表示只读缓存，会给所有调用者返回缓存对象的相同实例，因此这些对象不能修改，这提供了很重要的性能优势。</p><p>false表示读写缓存，会通过序列化返回缓存对象的拷贝，这样一来速度会慢一些，但是安全，因此是默认设置。</p></li></ul><h3 id="缓存查询顺序"><a href="#缓存查询顺序" class="headerlink" title="缓存查询顺序"></a>缓存查询顺序</h3><p>先查询二级缓存（前提是二级缓存已开启），因为二级缓存中可能有其他程序已经查询得到的数据，可以拿来直接使用。如果二级缓存中没有，再查询一级缓存，如果一级缓存中也没有命中，则会直接查询数据库。sqlSession关闭之后，一级缓存中的数据会写入二级缓存。</p><h3 id="整合第三方缓存EHCache"><a href="#整合第三方缓存EHCache" class="headerlink" title="整合第三方缓存EHCache"></a>整合第三方缓存EHCache</h3><p>第三方缓存主要是针对二级缓存。了解即可，无需专门记忆。</p><h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><blockquote><p>正向工程：先创建Java实体类，由框架负责实体类生成数据表。Hibernate是支持正向工程的。</p><p>逆向工程：先创建数据库表，由框架负责根据数据库表反向生成以下资源：</p><ol><li>Java实体类</li><li>Mapper接口</li><li>Mapper映射文件</li></ol></blockquote><p>逆向工程在工作中使用很少，这里只是粗略看过了视频了解，也没有深入学习。以后工作了遇到了再来学习吧。</p><h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2>]]></content>
    
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习手记</title>
    <link href="/2022/09/03/Git%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/"/>
    <url>/2022/09/03/Git%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE基础补充计划</title>
    <link href="/2022/09/01/JavaSE%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2022/09/01/JavaSE%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-SE基础补完计划"><a href="#Java-SE基础补完计划" class="headerlink" title="Java SE基础补完计划"></a>Java SE基础补完计划</h1><blockquote><p>Java SE基础是Java学习中的基石，后续的学习基本都需要依靠这些基础内容，如果这一部分的内容掌握不牢固，就会导致后续学习内容的晦涩难懂。</p><p>基于以上原因，加上自我感觉Java SE的内容可能只掌握了60%，因此完成这份补完计划十分重要。Java SE大体可以分为三个部分：</p><ul><li>Java基础语法：包括面向对象编程、集合、异常、反射等</li><li>操作系统相关：多线程，IO流等</li><li>数据结构与算法：表、树、哈希、KMP、动态规划等</li></ul><p>参考文档&amp;教程&amp;书籍</p><ul><li><a href="https://www.yuque.com/qingkongxiaguang/javase/xoxpqi">Java SE 笔记</a></li><li><a href="https://www.runoob.com/java/java-tutorial.html">Java教程-菜鸟教程</a></li><li>《Java 核心技术卷》</li></ul></blockquote><hr><h2 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h2><h3 id="Java语法与使用规范"><a href="#Java语法与使用规范" class="headerlink" title="Java语法与使用规范"></a>Java语法与使用规范</h3><p>对于Java的语法和使用规范是十分基础的东西，具体的内容可以参照文档&amp;教程&amp;书籍中的内容进行了解学习。</p><p>主要的内容包括：Java中的关键字，变量和常量，注释，基本数据类型以及数据类型之间的转换，运算符，流程控制。</p><p>了解完Java的语法和使用规范之后，就可以进行下一部分。</p><hr><h2 id="Java对象与多态"><a href="#Java对象与多态" class="headerlink" title="Java对象与多态"></a>Java对象与多态</h2><h3 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h3><p>面向对象程序设计（OOP）是当今主流的程序设计范式，而Java是面向对象的，必须熟悉OOP才能编写Java程序。</p><p>在使用OOP时，需要从对象的三个主要特性入手，分别是行为，状态（对象的状态不会自发改变，必须通过调用方法实现）和标识。对象这三个主要特性在彼此之间互相影响。</p><blockquote><p>传统的结构化程序设计通过设计一系列的过程（或者说算法）来求解问题，一旦确定了过程，就要考虑存储数据的方式。这也是Nikalus Wirth编著的《算法+数据结构&#x3D;程序》中，标题第一位是算法，第二位是数据结构的原因<br><em>面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。实际上，在面向对象中，只要对象可以满足要求，就不关心功能的具体实现过程，只需要满足用户的需求。</em> </p><p>​——Java核心技术卷</p></blockquote><h3 id="Java中的类"><a href="#Java中的类" class="headerlink" title="Java中的类"></a>Java中的类</h3><p>Java中的对象都基于类创建，这些类可以是Java自带的类，也可以是程序员自己编写的类。<strong>简单来说，类是对象的一个模板，有自己的属性，包括成员变量，成员方法等，我们可以通过调用类的成员方法来进行一些操作。</strong>（这里可以看下菜鸟教程：<a href="https://www.runoob.com/java/java-object-classes.html">Java对象和类</a>）</p><p>在使用面向对象程序设计时，经常需要分析用户的需求，识别出需要使用和设计的类。识别类最简单的方法就是在分析问题的过程中寻找名词，这些名词就代表着类，而方法由动词对应。当然，在实际开发中，更多的还是得依赖于个人的开发经验。</p><p>在Java中，类的加载机制也需要注意。类并不是在一开始就全部加载好，而是在需要时才会去加载，目的是提高速度，如以下情况下会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new创建对象的实例</li><li>调用类的静态方法</li><li>子类初始化</li><li>以及特殊情况</li></ul><p><strong>类与类之间，存在着三种常见的关系：</strong></p><ul><li>依赖（uses-a）：如果一个类的方法操纵另一个类的对象，就可以说一个类依赖于另一个类。在开发中，应该尽可能将相互依赖的类减少，使用术语来说，就是让类之间的耦合度最低。</li><li>聚合（has-a）：这个关系其实可以从英语出发，就是一个对象中存在另外一些对象，这样就可以说类与类之间存在聚合关系。其实我们更应该理解为包含。</li><li>继承（is-a）：继承是一种用于表示特殊与一般关系的。可以理解为社会中的父子关系。<em>（注意，继承内容是Java中非常重要的部分，笔者自身已经反复学习理解过多次，如果新手读者建议找找教程视频深刻学习体会）</em></li></ul><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p>抽象类和接口，其实就是类的抽象再抽象。</p><p>对于类的初步抽象，就是保留特征而不保留具体形态。比如对于方法，在抽象类中我可以定义却不去实现，保留给子类实现。</p><p>对抽象类的抽象，也即是对类的深度抽象，就是接口了。严格说它甚至不是一个类，只代表了某个功能，只包含对方法的定义。<strong>接口的功能需要由主体——也就是类来实现</strong>。</p><ul><li><a href="https://www.runoob.com/java/java-abstraction.html">Java 抽象类 | 菜鸟教程</a></li><li><a href="https://www.runoob.com/java/java-abstraction.html">Java 接口 | 菜鸟教程</a></li></ul><h3 id="包装类和枚举类"><a href="#包装类和枚举类" class="headerlink" title="包装类和枚举类"></a>包装类和枚举类</h3><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>虽然说Java是一种面向对象的语言，不过Java也不是完全面向对象的。例如Java中的基本数据类型就不是对象。当我们想通过对象的方式去使用基本数据类型时，就需要将其转换为相对应的对象。Java中提供这一服务的类就称之为包装类，将基本数据类型转换为对象的过程称为打包（装箱），反过来的过程称为拆包（拆箱）。这两个过程在Java中可以自动完成，也可以由程序员自己编写。</p><p><img src="/img/class1.jpg" alt="包装类"></p><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>有时候，我们想为对象添加一个描述或者一种状态（例如衣服的尺码有小、中、大、加大等，人的状态有睡觉、工作，吃饭等）。如果此时我们使用字符串来存储这一部分数据，就有可能出现外部传来的数据并不是我们想要的。这个时候，就可以使用枚举类来解决这个问题，这样就只能使用我们定义好的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//服装尺码的枚举类</span><br><span class="hljs-comment">//实际上，这句代码定义了一个类，这个类有这四个实例，所以在使用枚举类时，尽量不要构造新对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL , MEDIUM , LARGE , EXTRA_LARGE&#125;;<br></code></pre></td></tr></table></figure><p>此外，所有枚举类都是Enum类的子类，也就是说继承了Enum类的许多方法可以使用。</p><hr><h2 id="Java的异常机制与异常处理"><a href="#Java的异常机制与异常处理" class="headerlink" title="Java的异常机制与异常处理"></a>Java的异常机制与异常处理</h2><blockquote><p>一个程序的使用过程中不可能完全不存在BUG，代码跑不动才是常态。这是很正常的现象，关键是要在出现BUG之后优化程序，使之不断改进，不断趋于完美。</p><p>在Java 核心技术卷中建议在出现异常时，至少应该做到：</p><ul><li>向用户通告错误</li><li>保存所有的操作结果</li><li>允许用户以适当的形式退出程序</li></ul></blockquote><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p><img src="/img/ExceptionClass.jpg" alt="异常层次结构体系"></p><p>从上图其实可以很清晰的看出，Java中的异常其实也是一个类，继承自Throwable类，分为两种：Error类和Exception，其中Exception类还有IOException和RuntimeException两个子类。当然，如果现有的类不足以满足用户的需求，同样可以自己编写需要的子类。</p><ul><li>Error类描述的是Java运行是系统的内部错误和资源耗尽错误。如果出现了这样的内部错误，程序除了通告给用户同时尽力安全地终止程序外，其他的也无能为力。这种情况在实际开发很少出现。</li><li>Exception类是在开发中需要重点关注的部分。一般来说，由程序错误导致的异常术语RuntimeException；如果程序本身没有问题，不过由于 I&#x2F;O 错误这类问题导致的异常属于IOException。<ul><li>RuntimeException的异常还包括：错误的类型转换，数组访问越界，访问空指针</li><li>IOException的异常还包括：试图的文件尾部后面读取数据，试图打开一个错误格式的URL，试图根据给定的字符串查找Class对象，但是字符串表示的类并不存在</li></ul></li></ul><h3 id="异常的抛出，捕获及自定义"><a href="#异常的抛出，捕获及自定义" class="headerlink" title="异常的抛出，捕获及自定义"></a>异常的抛出，捕获及自定义</h3><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>如果调用方法时因为传入错误的参数，进而导致程序无法正常运行，此时应该手动抛出一个异常来终止程序，然后报告上一级方法执行出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;   <span class="hljs-comment">//捕获方法中会出现的异常</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>        <span class="hljs-comment">//声明抛出的异常类型</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;0不能做除数！&quot;</span>);  <span class="hljs-comment">//创建异常对象并抛出异常</span><br>        <span class="hljs-keyword">return</span> a/b;  <span class="hljs-comment">//抛出异常会终止代码运行</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>如果调用编译时异常的方法，但是依然不想去处理，可以同样的在方法上声明 throws 来继续交给上一级处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <span class="hljs-comment">//出现异常就再往上抛，而不是在此方法内处理</span><br>  test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <span class="hljs-comment">//声明抛出的异常类型</span><br>  <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;0不能做除数！&quot;</span>);  <span class="hljs-comment">//创建异常对象并抛出异常      </span><br>  <span class="hljs-keyword">return</span> a/b;  <br>&#125;<br></code></pre></td></tr></table></figure><p>出现类似以上代码的情况，连main方法都声明抛出异常时，这时出现的异常就会交给JVM处理，JVM会直接终止程序并在控制台打印栈追踪信息（这也是默认的处理方法）</p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>抛出一个异常十分容易，只要将它抛出就行了。不过，一些代码必须捕获异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    some code...<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    some code...<br>&#125;<br></code></pre></td></tr></table></figure><p>try&#x2F;catch语句是捕获一个异常必须设置的。<strong>如果try代码块中抛出了一个在catch子句中说明的异常，那么，首先程序会跳过try代码块中的其余代码，执行catch中的处理器代码。如果没有出现任何异常，则不会执行catch中的代码。如果出现没有声明的异常类型，那么程序就会立刻退出。</strong></p><blockquote><p>编译器严格执行throws说明符，如果调用一个抛出已检查异常（非派生于Error类和RuntimeException类的异常）的方法，就必须对它进行处理，或者将其传递出去（即抛出）。</p><p>通常，应捕获那些知道如何处理的异常，传递那些不知道怎么处理的异常。如果想将异常传出去，就必须在方法的首部添加一个throws说明符，以便告知调用者这个方法可能会抛出异常。</p><p>阅读Java API文档，以便知道每个方法可能会抛出的异常，然后决定是自己处理，还是添加到throws列表里。对后一种，不必犹豫，将异常直接交给能够胜任的处理器进行处理会比压制对它的处理更好。</p><p>​——《Java核心技术卷》</p></blockquote><p><strong>对于捕获多个异常来说，就是在try&#x2F;catch语句基础上，再多加入声明不同异常类型的catch语句。</strong></p><p>此外，还可以在catch语句中再抛出一个异常，这样做的目的一般是改变异常的类型。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>异常的自定义非常简单，只要继承部分的知识掌握的足够，自定义异常的编写更多是对父类方法的重写。</p><hr><h3 id="Java中的断言，日志和调试"><a href="#Java中的断言，日志和调试" class="headerlink" title="Java中的断言，日志和调试"></a>Java中的断言，日志和调试</h3><h4 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h4><p>在程序设计中，代码运行测试是必不可少的，这就要求在程序中插入测试代码。一般的测试代码在测试完成后不会自动删除，大量的测试代码会导致程序的运行变慢。</p><p>断言机制就是允许在测试时向代码插入检查语句，到代码发布时，这些插入的语句将会被自动的移走。Java中引入 assert 关键字来使用断言。</p><p>不过，在现在的开发中，断言并不推荐使用。详见：<a href="https://developer.aliyun.com/article/409118">Java陷阱之assert关键字</a></p><hr><h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><h3 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h3><p>泛型，其实就是为了编写的代码可以被不同<strong>类型对象</strong>所使用。</p><p>在没使用泛型之前，代码可能是这样写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>&#123;<br>    <span class="hljs-keyword">private</span> String[] paraList; <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;...&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String para)</span>&#123;...&#125;;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这样一个List类，在使用时只能添加String类型的数据，如果要使用其他类型，好像得重写一下。有人可能会想到Object类，它是所有类的超类，修改如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>&#123;<br>    <span class="hljs-keyword">private</span> Object[] paraList; <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;...&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object para)</span>&#123;...&#125;;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><p>可是，这里一样会出现两个问题：</p><ul><li><p>获取一个值时必须进行强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>可以在数组中添加任何类的对象，容易导致一些无法预料的错误。</p></li></ul><p>基于以上原因，泛型的作用就凸显出来了。相同代码，完全可以这样编写（这里的T只能是类，不可以使用基本数据类型，可以使用包装类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>&lt;T&gt;&#123;<br>   <span class="hljs-keyword">private</span> T[] paraList; <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;...&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T para)</span>&#123;...&#125;;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定义泛型类-x2F-方法-x2F-接口"><a href="#定义泛型类-x2F-方法-x2F-接口" class="headerlink" title="定义泛型类&#x2F;方法&#x2F;接口"></a>定义泛型类&#x2F;方法&#x2F;接口</h3><p>泛型类就是具有一个或者多个类型变量的类。它的定义较为简单，参考上面的例子，使用一对尖括号（&lt;&gt;）将类型变量 T 括起来放在类名的后面。如果有多个，还可以使用K，V，U，S等，中间使用逗号隔开。</p><hr><h2 id="集合类和集合接口"><a href="#集合类和集合接口" class="headerlink" title="集合类和集合接口"></a>集合类和集合接口</h2><p>Java的类库中有这么一些类，可以帮助我没在程序设计中实现传统的数据结构，比如链表，堆栈，队列，散列表等等。数据结构是程序设计中必学的课程，也有许多相关的书籍介绍和讲解使用方法，此处不再赘述。</p><p>此外，在学习数据结构时，一般会穿插讲解算法，对于一般人来说，算法只需要了解几种常见的排序算法和查找算法即可，在了解的基础上懂得如何使用，以及理解实现过程便可，并不需要在深入了解算法。</p><hr><h2 id="Java中的多线程"><a href="#Java中的多线程" class="headerlink" title="Java中的多线程"></a>Java中的多线程</h2><p>多线程基础介绍部分，笔者之前就有写过博客，详见：<a href="https://blake315.github.io/2022/09/01/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/">Java多线程</a></p><p>内容有错误之处，欢迎指出。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven学习手记</title>
    <link href="/2022/09/01/maven%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/"/>
    <url>/2022/09/01/maven%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven——强力好用的Java项目管理工具"><a href="#Maven——强力好用的Java项目管理工具" class="headerlink" title="Maven——强力好用的Java项目管理工具"></a>Maven——强力好用的Java项目管理工具</h1><blockquote><p>Maven在美国是一个口语化的词语，意思是专家，内行。也相当于汉语中的老炮儿，老师傅。正所谓老炮儿在手，管理无忧。</p><p>我们要学的Maven，实际上是一个项目管理工具，可以对项目进行构建、依赖管理。经过发展，Maven已经不仅仅可以管理Java项目，也可以对例如Ruby，Scala等语言编写的项目进行项目管理。</p><p>参考教程&#x2F;文档：</p><ul><li><a href="http://mvnbook.com/index.html">Maven教程网</a></li><li><a href="https://wuhang.xyz/fa714294.html">学习使用Maven构建项目</a></li><li><a href="https://www.dba.cn/book/maven/">Maven中文手册</a></li></ul></blockquote><hr><h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><h3 id="Java项目管理工具的历史与发展"><a href="#Java项目管理工具的历史与发展" class="headerlink" title="Java项目管理工具的历史与发展"></a>Java项目管理工具的历史与发展</h3><p>对于Java项目管理工具，主要有三个主要工具，Ant、Maven以及Gradle（按照出现时间）。最开始的Java项目管理工具是Ant，之后才出现了Maven，严格来说，Ant和Maven之间是兄弟关系，都是Apache基金会的项目。对于现行的Java企业开发来说，Ant已经销声匿迹，而新出现的Gradle发展迅速，大有取代Maven地位的趋势，不过就目前来讲，Maven仍是Java项目管理工具中的王者。</p><p>对于三个管理工具的简单接受和分析，百科及大量的博客已有介绍，我也不再赘述，这里推荐一下朋友Matty写的简单介绍。（<a href="https://wuhang.xyz/fa714294.html">学习使用Maven构建项目</a>，1.2节）</p><h3 id="Maven的组成"><a href="#Maven的组成" class="headerlink" title="Maven的组成"></a>Maven的组成</h3><blockquote><p>Maven是一个项目管理工具，它包含了：项目对象模型 (POM，Project Object Model)，项目生命周期(Project Lifecycle)，依赖管理系统(Dependency Management System)和各种插件。插件主要用来实现生命周期各个阶段(phase)的目标(goal)。Maven的组成如下所示：</p><p><img src="http://mvnbook.com/static/image/maven-core.png" alt="概念模型"></p><p>不过，上述介绍对于完全没有 Maven 实践经验的人来说，看了等于没看，并没有用处。只有当读者通读本站内容之后，反过头再看，才能豁然开朗。(<a href="http://mvnbook.com/index.html">Maven教程网</a>）</p></blockquote><h3 id="Maven的特性"><a href="#Maven的特性" class="headerlink" title="Maven的特性"></a>Maven的特性</h3><ul><li><p><strong>依赖管理系统</strong>。Maven使用groupId，artifactId，version组成的“坐标”来标识依赖。当项目需要引入一个外部依赖时，只需在配置文件里添加几行代码；如果项目所依赖的Jar包需要升级时，只需要修改配置文件中的一行。</p></li><li><p><strong>多模块构建</strong>。</p><blockquote><p>在Maven中，可以为当前项目定义一个parent POM（实际上是一个pom.xml文件），该POM中可以使用modules配置来定义一组子模块。parent POM不会有实际构建的产出，但parent POM中的build配置以及dependencies配置都会自动继承给子模块。</p></blockquote></li><li><p><strong>一致的项目结构</strong>。Maven通过指定一套项目目录结构为标准的Java项目结构，解决了不同IDE带来的文件目录不一致的问题。</p><p>对于这个标准的项目目录结构，网上的讲解和图片非常多，另外这个目录一般都是Maven自动生成，我们只需要知道什么文件应该放在什么文件夹即可。</p><blockquote><p>推荐阅读：<a href="http://mvnbook.com/maven-standard-project-directory.html">Maven标准项目目录-Maven教程网</a></p></blockquote></li><li><p><strong>一致的构建模型和插件机制</strong></p></li></ul><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>学习Maven的准备工作分为两个部分，官网下载zip包并解压，配置环境变量。这里的具体步骤参考<a href="http://mvnbook.com/maven-download.html">Maven下载与安装</a></p><blockquote><p>我自己在按照教程配置环境变量的时候，出现了以下的一个报错： could not create the JAVA  virtual machine。经过搜索，发现这是由于MAVEN_OPTS设置异常导致。错误的地方非常好笑，就是变量配置少了一个空格。</p><p>还是那句话，要相信自己在配置过程中遇到的所有问题，都会有人遇到过，并且都能在网上找到解决方法。</p></blockquote><p>在执行第一次Maven命令时，默认会在用户目录下的.<em>m&#x2F;respository</em>中下载依赖，这个位置在Maven中称为仓库。如果需要修改，可以在Maven目录中的setting.xml文件中修改。（这里建议修改，方便文件管理）</p><hr><h2 id="Maven中的仓库"><a href="#Maven中的仓库" class="headerlink" title="Maven中的仓库"></a>Maven中的仓库</h2><p>在Maven中的任何一个依赖，插件或者项目构建时的输出，都称为”<strong>构件</strong>“。对于这些构件，Maven仓库都可以帮助我们管理。此外，仓库是一个位置，在项目中引入的第三方库的位置，在Maven中就称为仓库。</p><h3 id="仓库的原理"><a href="#仓库的原理" class="headerlink" title="仓库的原理"></a>仓库的原理</h3><p>我们使用Maven的第一目的就是可以更好的管理我们的项目（主要是Java项目），管理项目其实就是管理依赖和第三方库（也即是Jar包）。仓库本质上就是一个用来放置Jar包的地方。在本地开发时，会查看仓库中是否有Jar包，有就直接用，没有就从远程仓库下载。所以项目，本地仓库以及远程仓库的依赖关系就是：项目依赖于本地仓库，本地仓库依赖于远程仓库。</p><h3 id="三种Maven仓库类型"><a href="#三种Maven仓库类型" class="headerlink" title="三种Maven仓库类型"></a>三种Maven仓库类型</h3><ul><li>本地仓库（local）：本机放置构件的地方，Maven从远程仓库下载的构件都存放在此处。需要注意的是，本地仓库只有在执行第一次Maven命令时才会生成，默认路径在用户目录下一个.<em>m&#x2F;respository</em>中。如果需要修改，可以在Maven目录中的setting.xml文件中修改。</li><li>中央仓库（central）：这是Maven社区提供的仓库，里面包含常用类库。不过由于Maven社区的服务器在海外，国内访问下载类库的速度偏慢，有时候甚至会断连，针对这个原因，我们同样可以在Maven目录中的setting文件中修改配置文件，将下载地址变更为国内阿里的镜像网址。</li><li>远程私服（remote）：一般指公司内部使用的仓库。</li></ul><hr><h2 id="Maven项目的目录结构"><a href="#Maven项目的目录结构" class="headerlink" title="Maven项目的目录结构"></a>Maven项目的目录结构</h2><p>上面说过，Maven的一大特性之一就是规定了一致的项目目录结构，因此在不同的IDE中创建的Maven项目都是一致的，不存在目录不兼容的问题。</p><table><thead><tr><th align="center">目录</th><th align="center">存放</th></tr></thead><tbody><tr><td align="center">${basedir}</td><td align="center">pom.xml和所有子目录</td></tr><tr><td align="center">${basedir}&#x2F;src&#x2F;main&#x2F;java</td><td align="center">项目的Java源码</td></tr><tr><td align="center">${basedir}&#x2F;src&#x2F;main&#x2F;resources</td><td align="center">项目的资源文件，例如.property文件、图片等</td></tr><tr><td align="center">${basedir}&#x2F;src&#x2F;test&#x2F;java</td><td align="center">测试使用的Java源码</td></tr><tr><td align="center">${basedir}src&#x2F;test&#x2F;resources</td><td align="center">测试使用的资源文件</td></tr><tr><td align="center">${basedir}&#x2F;target（自动生成）</td><td align="center">所有输出</td></tr><tr><td align="center">${basedir}&#x2F;target&#x2F;classes（自动生成）</td><td align="center">编译后的class文件</td></tr></tbody></table><blockquote><ul><li>pom.xml是最核心的配置文件，记录Maven项目所需要的素有jar包的依赖以及所有插件的依赖</li><li>上面的目录命名和层次结构都是固定的，需要注意不要写错大小写和单复数</li></ul></blockquote><h3 id="实操：使用IDEA创建Maven项目"><a href="#实操：使用IDEA创建Maven项目" class="headerlink" title="实操：使用IDEA创建Maven项目"></a>实操：使用IDEA创建Maven项目</h3><p>在IDEA中选择新建项目，接着选择Maven，然后勾选从原型创建，在下面的原型中选择quickstart，之后进行下一步。</p><p><img src="C:\Users\Thales\AppData\Roaming\Typora\typora-user-images\image-20220925131957939.png" alt="image-20220925131957939"></p><p>接下来就是为项目命名，此外，还可以在下方的工件坐标中修改三个基础标识。</p><p><img src="C:\Users\Thales\AppData\Roaming\Typora\typora-user-images\image-20220925145910353.png" alt="image-20220925145910353"></p><p>第三步就是选择Maven的主路径，用户设置文件和本地仓库地址。在这里需要注意检查以下对应的路径是否正确。点击完成后IDEA便会开始初始化，并下载对应的依赖和插件等。</p><p><img src="C:\Users\Thales\AppData\Roaming\Typora\typora-user-images\image-20220925150110435.png" alt="image-20220925150110435"></p><p><img src="C:\Users\Thales\AppData\Roaming\Typora\typora-user-images\image-20220925132210608.png" alt="image-20220925132210608"></p><p>最后一步，quickstart原型中是不会有resources目录文件的，需要我们参考标准目录结构在main和test中分别创建对应的文件夹，并标记为资源根和测试资源根。</p><blockquote><p>我这里截图中的文件夹名打错了，后面已经更改。</p></blockquote><p><img src="C:\Users\Thales\AppData\Roaming\Typora\typora-user-images\image-20220925132525433.png" alt="image-20220925132525433"></p><blockquote><p>在初次构建Maven项目的时候，一般来说是会要出现意外的。例如我在创建的时候就出现了两个比较大的问题。</p><ul><li><p><img src="C:\Users\Thales\AppData\Roaming\Typora\typora-user-images\image-20220925133622478.png" alt="image-20220925133622478"></p><p>第一个是这个问题，这个报错原因是我下载的Maven版本是3.8.6，但是IDEA版本是2021。<strong>这两个版本之间不兼容</strong>。是的，就是不兼容，解决方法很简单，把Maven版本降低就好了，最好是3.6版本。这个坑是我第二次踩了，之前是使用eclipse创建web项目时发现自己的版本是社区版，并不支持Web项目，一番操作之后才得以解决，这次又是一番折腾。<strong>血的教训，下载任何东西记得先看看版本是否可用</strong></p></li><li><p><img src="C:\Users\Thales\AppData\Roaming\Typora\typora-user-images\image-20220925134916772.png" alt="image-20220925134916772"></p><p>这是第二个问题，在远程目录中找不到原型（比起上一个问题还行，这个只是一个警告）。导致原因也没太搞懂，因为我已经更换国内镜像源了，还是会出现此处错误。</p><p>此处贴一个解决方案： <a href="https://www.cnblogs.com/loufangcheng/p/12861762.html">解决方法：No archetype…</a></p></li></ul></blockquote><p>到这里，就算使用Maven构建了一个Java项目了，但是到这里还差最后一步，修改默认pom中的设置。</p><blockquote><p><em>引用搬运自<a href="https://wuhang.xyz/fa714294.html">学习使用Maven构建项目</a></em></p><h4 id="修改pom-xml-quickstart通用操作"><a href="#修改pom-xml-quickstart通用操作" class="headerlink" title="修改pom.xml (quickstart通用操作)"></a>修改pom.xml (quickstart通用操作)</h4><blockquote><p>针对Java项目的pom.xml修改方案，是所有用quickstart模板创建的项目的通用操作。</p></blockquote><ul><li><p><strong>必须把JDK版本从默认的1.7改成你正在使用的版本</strong></p></li><li><p>可以删除多余的junit依赖</p></li><li><p>可以删除多余的<pluginManagement>配置（可以把标签块折叠起来再删，避免误删）</p><blockquote><p><pluginManagement>为什么是多余的？</p><p><pluginManagement>一般是用在父pom中的，有点Java抽象类的意思，只是一种声明，实际上Maven并不会为当前项目下载里面的那些插件。所以，如果你构建的不是多模块项目，或者虽然构建了多模块项目但是没有什么需要被子模块继承的插件声明，或者你压根不知道什么是多模块项目，那么这个配置对你来说就是多余的。</p><p>扩展资料：</p><p><a href="https://www.cnblogs.com/whx7762/p/8072755.html">Maven中plugins和pluginManagement的区别 - hxwang - 博客园</a></p><p><a href="https://stackoverflow.com/questions/10483180/what-is-pluginmanagement-in-mavens-pom-xml">java - What is pluginManagement in Maven’s pom.xml? - Stack Overflow</a></p></blockquote></li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式的进化之路</title>
    <link href="/2022/09/01/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/09/01/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式的进化之路"><a href="#Lambda表达式的进化之路" class="headerlink" title="Lambda表达式的进化之路"></a>Lambda表达式的进化之路</h1><h2 id="为什么要使用Lambda表达式"><a href="#为什么要使用Lambda表达式" class="headerlink" title="为什么要使用Lambda表达式"></a>为什么要使用Lambda表达式</h2><ul><li>可以简洁代码，提高代码的可读性</li><li>可以避免匿名内部类定义过多导致逻辑紊乱</li><li>在原先实现接口抽象方法的时候，需要通过定义一个实现接口的外部类来实现，后面变为定义内部静态类，然后变为用局部内部类实现，再后面变成了定义匿名内部类来实现，最后的最后，为了代码的更加简洁，推出了Lambda表达式，最终实现了用一行代码完成之前多行代码的效果</li></ul><h2 id="Lambda表达式的注意点"><a href="#Lambda表达式的注意点" class="headerlink" title="Lambda表达式的注意点"></a>Lambda表达式的注意点</h2><ul><li><p><strong>Lambda表达式实际上属于是函数式编程的概念，所以在使用的时候要知道是否属于函数式编程</strong></p></li><li><p><strong>Lambda表达式的实现依赖于接口和父类，所以必须有两者之一才能实现Lam表达式</strong></p></li><li><p><strong>Lambda表达式实现的接口中要求只有一个抽象方法，如果有多个抽象方法就无法使用Lambda表达式来编程</strong></p></li><li><p><strong>Lambda表达式即适用于无参方法，也适用于含参方法</strong></p></li><li><p><em>Lambda表达式最早在JDK 8中开始出现，所以只有 JDK 8 以后的版本才支持</em></p><hr></li></ul><h3 id="下面是Lambda表达式的实现过程"><a href="#下面是Lambda表达式的实现过程" class="headerlink" title="下面是Lambda表达式的实现过程"></a>下面是Lambda表达式的实现过程</h3><ol><li><p><em><strong>最开始使用的是定义外部实现类来完成接口</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">tt1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//用外部类来实现接口，首先需要在主类外定义另外一个类，之后再在内部类中创建对象</span><br>        <span class="hljs-comment">//这样对于那些只需要使用一次的接口来说比较的麻烦，而且也会使整个代码变得臃肿，给其他开发人员带来阅读困难</span><br>        <span class="hljs-type">lover</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover</span>();<br>        l1.love();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILove</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//外部实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lover</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出为：I love you lover ---&gt; 1</span><br></code></pre></td></tr></table></figure></li><li><p><em><strong>开始使用静态内部类来实现</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">tt1</span> &#123;<br>    <span class="hljs-comment">//静态内部类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 2&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//用外部类来实现接口，首先需要在主类外定义另外一个类，之后再在内部类中创建对象</span><br>        <span class="hljs-comment">//这样对于那些只需要使用一次的接口来说比较的麻烦，而且也会使整个代码变得臃肿，给其他开发人员带来阅读困难</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover1</span>();<br>        l1.love();<br>        <span class="hljs-comment">//使用静态内部类来实现，由于实现类和main方法位于相同主类中，方便了开发人员阅读，但是实现过程还是比较麻烦</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover2</span>();<br>        l2.love();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个函数式接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILove</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//外部实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lover1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出为：I love you my lover ---&gt; 1</span><br><span class="hljs-comment">//   I love you my lover ---&gt; 2</span><br></code></pre></td></tr></table></figure></li><li><p><em><strong>使用局部内部类使用</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">tt1</span> &#123;<br>    <span class="hljs-comment">//静态内部类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 2&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//用外部类来实现接口，首先需要在主类外定义另外一个类，之后再在内部类中创建对象</span><br>        <span class="hljs-comment">//这样对于那些只需要使用一次的接口来说比较的麻烦，而且也会使整个代码变得臃肿，给其他开发人员带来阅读困难</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover1</span>();<br>        l1.love();<br>        <span class="hljs-comment">//使用静态内部类来实现，由于实现类和main方法位于相同主类中，方便了开发人员阅读，但是实现过程还是比较麻烦</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover2</span>();<br>        l2.love();<br><br>        <span class="hljs-comment">//局部内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 3&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover3</span>();<br>        l3.love();<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个函数式接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILove</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//外部实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lover1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出为：I love you my lover ---&gt; 1</span><br><span class="hljs-comment">// I love you my lover ---&gt; 2</span><br><span class="hljs-comment">// I love you my lover ---&gt; 3</span><br></code></pre></td></tr></table></figure></li><li><p><em><strong>使用匿名内部类实现接口</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">tt1</span> &#123;<br>    <span class="hljs-comment">//静态内部类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 2&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//用外部类来实现接口，首先需要在主类外定义另外一个类，之后再在内部类中创建对象</span><br>        <span class="hljs-comment">//这样对于那些只需要使用一次的接口来说比较的麻烦，而且也会使整个代码变得臃肿，给其他开发人员带来阅读困难</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover1</span>();<br>        l1.love();<br>        <span class="hljs-comment">//使用静态内部类来实现，由于实现类和main方法位于相同主类中，方便了开发人员阅读，但是实现过程还是比较麻烦</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover2</span>();<br>        l2.love();<br><br>        <span class="hljs-comment">//局部内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 3&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover3</span>();<br>        l3.love();<br><br>        <span class="hljs-comment">//使用内部匿名类</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ILove</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 4&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个函数式接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILove</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//外部实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lover1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出为：I love you my lover ---&gt; 1</span><br><span class="hljs-comment">//   I love you my lover ---&gt; 2</span><br><span class="hljs-comment">//   I love you my lover ---&gt; 3</span><br><span class="hljs-comment">//  I love you my lover ---&gt; 4</span><br></code></pre></td></tr></table></figure></li><li><p><em><strong>最后使用Lambda表达式实现函数式接口</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">tt1</span> &#123;<br>    <span class="hljs-comment">//静态内部类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 2&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//用外部类来实现接口，首先需要在主类外定义另外一个类，之后再在内部类中创建对象</span><br>        <span class="hljs-comment">//这样对于那些只需要使用一次的接口来说比较的麻烦，而且也会使整个代码变得臃肿，给其他开发人员带来阅读困难</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover1</span>();<br>        l1.love();<br>        <span class="hljs-comment">//使用静态内部类来实现，由于实现类和main方法位于相同主类中，方便了开发人员阅读，但是实现过程还是比较麻烦</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover2</span>();<br>        l2.love();<br><br>        <span class="hljs-comment">//局部内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">lover3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 3&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">lover3</span>();<br>        l3.love();<br><br>        <span class="hljs-comment">//使用内部匿名类</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ILove</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 4&quot;</span>);<br>            &#125;<br>        &#125;;<br>        l4.love();<br><br>        <span class="hljs-comment">//使用Lambda表达式实现接口</span><br>        <span class="hljs-type">ILove</span> <span class="hljs-variable">l5</span> <span class="hljs-operator">=</span> () -&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 5&quot;</span>);<br>        &#125;;<br>        l5.love();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个函数式接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILove</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//外部实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lover1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILove</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">love</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love you my lover ---&gt; 1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出为：</span><br>I love you my lover ---&gt; <span class="hljs-number">1</span><br>I love you my lover ---&gt; <span class="hljs-number">2</span><br>I love you my lover ---&gt; <span class="hljs-number">3</span><br>I love you my lover ---&gt; <span class="hljs-number">4</span><br>I love you my lover ---&gt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="关于Lambda表达式的更加极致的简化（针对有参数的Lambda表达书）"><a href="#关于Lambda表达式的更加极致的简化（针对有参数的Lambda表达书）" class="headerlink" title="关于Lambda表达式的更加极致的简化（针对有参数的Lambda表达书）"></a>关于Lambda表达式的更加极致的简化（针对有参数的Lambda表达书）</h3><ul><li><strong>简化数据类型</strong>  在Lambda表达式中可以将参数的数据类型省略，只留下一个数据名称。比较特殊的是如果有多个参数，省略的时候应该将所有参数的数据类型都省略，不然就全部不省略，而且需要用括号将参数包含在内。</li><li><strong>省略括号</strong> 参照上一条，只有一个参数要求的时候才可以省略括号</li><li><strong>省略花括号</strong> 在Lambda表达式中，只有当输出语句或者代码只有一行的时候可以省略花括号。假如有多条执行代码，还是需要用花括号将代码包含在内</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程详解</title>
    <link href="/2022/09/01/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <url>/2022/09/01/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多线程详解"><a href="#Java多线程详解" class="headerlink" title="Java多线程详解"></a>Java多线程详解</h1><h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="多任务，多线程"><a href="#多任务，多线程" class="headerlink" title="多任务，多线程"></a>多任务，多线程</h3><p><strong>多任务</strong>情况中，虽然可以完成，但是实际上，多任务的完成是由一个一个小任务的完成来实现的，也就是说<em>在执行多任务时，不是同时执行多个任务，而是一个时间段内只完成一个任务。</em></p><p><strong>多线程</strong>情况中，则是<em>依赖于CPU的功能</em>，<em><strong>瞬间同时执行多个线程，或者说主线程和子线程并行交替执行。</strong></em></p><h3 id="程序-进程-线程"><a href="#程序-进程-线程" class="headerlink" title="程序 进程 线程"></a>程序 进程 线程</h3><ol><li><p><strong>程序</strong>就是指令和数据的有序集合，本身没有任何运行的含义，<strong>是一个静态的概念</strong></p></li><li><p><strong>进程</strong>是<em>执行程序的一次执行过程</em>，<strong>是一个动态的概念</strong></p></li><li><p><strong>线程</strong>包含在进程中，<em><strong>一个进程可以由多个线程，一个进程至少有一个线程（主线程main），线程是CPU调度和执行的单位</strong></em></p></li></ol><h3 id="线程的三种创建方式"><a href="#线程的三种创建方式" class="headerlink" title="线程的三种创建方式"></a>线程的三种创建方式</h3><ul><li><p>通过声明Thread类的子类，重写run类的方法Thread创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//继承Thread类，重写run方法中的代码块</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Testing01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//run方法代码块</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;run方法运行次数&quot;</span> + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//开启线程的方法：1.创建对象 2.调用start方法</span><br>        <span class="hljs-type">Testing01</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Testing01</span>();<br>        t1.start();<br>        <span class="hljs-comment">//主线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;主线程运行次数&quot;</span> + i);<br>        &#125;<br><span class="hljs-comment">//线程不一定是立即执行的，实际的执行需要看CPU的调度，基本  是随机调度，随机执行。因为CPU的执行一个线程的速度非常  快，所以我们感觉起来像是在同时执行多个线程，但是实际上是一个一个线程执行的</span><br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p>Thread类使用案例：下载网图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.io.FileUtils; <br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-comment">//联系Thread：实现多线程图片下载器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Testing02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><span class="hljs-comment">//声明私有变量</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String name;<br><span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Testing02</span><span class="hljs-params">(String url , String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">//下载图片的线程体</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">WebDownloader</span> <span class="hljs-variable">w1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebDownloader</span>();<br>        w1.downloader(url , name);<br>        System.out.println(<span class="hljs-string">&quot;下载了文件名为：&quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Testing02</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Testing02</span>(<span class="hljs-string">&quot;http://image.biaobaiju.com/uploads/20190227/22/1551276917-PGHykpWFAn.jpeg&quot;</span>,<span class="hljs-string">&quot;1.jpeg&quot;</span>);<br>        t1.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebDownloader</span>&#123;<br>    <span class="hljs-comment">//下载方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloader</span><span class="hljs-params">(String url , String name)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileUtils.copyURLToFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url) , <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(name));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;IO异常，downloader方法出现问题&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>通过实现Runnable创建线程</p><ul><li>定义Runnable类实现Runnable接口</li><li>实现run()方法，编写线程执行体</li><li>创建线程对象，调用start（）方法启动线程</li><li>runnable实现类的运行还需要借助创建Thread对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Testing03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//run方法线程体</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学代码&quot;</span> + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建runnable接口的实现类对象</span><br>        <span class="hljs-type">Testing03</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Testing03</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t3).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><em>一般在Java中推荐使用通过Runnable类实现线程，这是由Java的单继承性质决定的，使用Runnable接口，就可以实现用多个线程对同一对象进行操作了</em></p><p><em><strong>同样的，多线程操作同一个对象也带来一个问题，被操作的对象会很容易出现数据异常等问题，所以还需要通过Java并发控制来解决</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//模拟用户抢票（由于没有加入并发控制，所有执行结果会出现两个人抢到同一张票的错误）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Testing04</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//调用sleep方法，人为制造延迟</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ticketNums &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到了第&quot;</span> + ticketNums-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Testing04</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Testing04</span>();<br><span class="hljs-comment">//实现多线程操作同一个对象tt</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tt,<span class="hljs-string">&quot;小米&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tt,<span class="hljs-string">&quot;华为&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tt,<span class="hljs-string">&quot;oppo&quot;</span>).start();<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>实现Callable接口（了解即可）</p><ol><li><p>需要返回数值</p></li><li><p>重写call方法，需要抛出异常</p></li><li><p>创建目标对象</p></li><li><p>创建执行服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里有线程池的方法</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ser</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></li><li><p>提交执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;Boolean&gt; r1 = ser.submit(t1);<br>Future&lt;Boolean&gt; r2 = ser.submit(t2);<br>Future&lt;Boolean&gt; r3 = ser.submit(t3);<br></code></pre></td></tr></table></figure></li><li><p>获取结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">re1</span> <span class="hljs-operator">=</span> r1.get();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">re2</span> <span class="hljs-operator">=</span> r2.get();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">re3</span> <span class="hljs-operator">=</span> r3.get();<br></code></pre></td></tr></table></figure></li><li><p>关闭服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ser.shutdown();<br></code></pre></td></tr></table></figure></li></ol></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown语法的学习</title>
    <link href="/2022/09/01/markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/09/01/markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown语法的学习"><a href="#MarkDown语法的学习" class="headerlink" title="MarkDown语法的学习"></a>MarkDown语法的学习</h1><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>​设置标题方法是在前面加#号，一级标题（最大）是加#+空格 ，二级标题是加##+空格，之后的以此类推。</p><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><em>在文本的前后分别加上一个星号表示斜体字</em></p><p><strong>在文本的前后分别加上两个星号表示字体加粗</strong></p><p><em><strong>在文本的前后分别加上三个星号表示斜体加粗</strong></em></p><p><del>在文本的前后分别加上两个波浪线</del></p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>在文本的开头加上 &gt; 表示文本引用。一般用于引用他人的文章或是博客</p></blockquote><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>连续三个 — 表示一道分割线</p><p>也可以用连续三个 *** 表示一道分割线</p><hr><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p><img src="C:\Users\Thales\Desktop\111.png" alt="插入图片举例"></p><p><strong>输入一个！以及在中括号输入插入图片的名称，再在后面的小括号中选择插入的本地图片即可（这是针对本地图片插入的例子）</strong></p><hr><p>![在线图片举例](<a href="http://inews.gtimg.com/newsapp_match/0/12014684244/0.jpg&amp;refer=http://inews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg">http://inews.gtimg.com/newsapp_match/0/12014684244/0.jpg&amp;refer=http://inews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg</a> (1080×1350) (baidu.com)](<a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_match%2F0%2F12014684244%2F0.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638095138&amp;t=85d422240312fcf57a528b5c153c2de4">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_match%2F0%2F12014684244%2F0.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638095138&amp;t=85d422240312fcf57a528b5c153c2de4</a>))</p><p><strong>对于在线图片的插入，语法上是没有改变，不过需要注意的是在后面小括号中需要复制黏贴上在线图片的源码，或者说图片的在线位置(具体方法是在网页右键后选择查看，在里面查看)</strong></p><p><img src="C:\Users\Thales\Desktop\222.png" alt="在线图片源码"></p><p><em>上面就是在线图片的源码示例</em></p><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><strong>超链接</strong>可以在文章中插入一个<em>可以点击的按钮</em>，点击后就可以跳转到设置好的网站</p><p><em><strong>具体语法是输入一个半角的中括号，在中括号中设置超链接的名字，后面输入一个半角的小括号，在小括号中输入想要跳转的网站</strong></em></p><p>[例如现在点击这个超链接就可以转到我的博客](<a href="https://www.cnblogs.com/ZeeWay/">Thales_ZeeWay - 博客园 (cnblogs.com)</a>)</p><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ol><li><em>有序排列</em>，<em><strong>语法是输入1.+空格</strong></em>，就可以自动生成有序排列</li><li><em>后续排序直接回车键就可以</em></li></ol><ul><li><em>这是无序排列</em>，<em><strong>语法是输入- + 空格</strong></em> ，一样可以自动的生成</li></ul><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><em>生成列表的最简单也是最方便的方式就是右键选择插入列表即可</em></p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><em><strong>代码块的语法是 &#96;&#96;&#96; + 输入代码所属的语言</strong></em></p><p><em>下面例子就是以Java为例</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    System.out.print(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125; <br></code></pre></td></tr></table></figure><p><em>“本站所有文章均为原创，欢迎转载，请注明文章出处：<a href="https://www.cnblogs.com/ZeeWay/p/15481997.html">MarkDown学习随笔 - Thales_ZeeWay - 博客园 (cnblogs.com)</a>)。百度和各类采集站皆不可信，搜索请谨慎鉴别。技术类文章一般都有时效性，本人习惯不定期对自己的博文进行修正和更新，因此请访问出处以查看本文的最新版本。”</em></p><p><em>作者：Thales_ZeeWay<br>链接：<a href="https://www.cnblogs.com/ZeeWay/p/15481997.html">原文链接</a><br>来源：博客园</em><br><em><strong>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong></em></p>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的生命历程</title>
    <link href="/2022/09/01/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
    <url>/2022/09/01/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="线程的生命历程"><a href="#线程的生命历程" class="headerlink" title="线程的生命历程"></a>线程的生命历程</h1><h2 id="线程的五大状态"><a href="#线程的五大状态" class="headerlink" title="线程的五大状态"></a><em>线程的五大状态</em></h2><ul><li><strong>创建状态</strong>：简而言之，当创建线程对象的代码出现的时候，此时线程就进入了创建状态。这时候的线程只是行代码而已。<em>只有调用线程的start（）方法时，线程的状态才会改变，进入就绪状态</em></li><li><strong>就绪状态</strong>：在这个状态下的线程，<strong>已经做好了随时运行的准备，但是并不意味着会立刻开始运行。</strong>还需要等待CPU的<em>随机调度，随机运行</em>。<em>只有当线程被CPU调度运行成功</em>，此时的线程才算是进入下一个状态——运行状态。</li><li><strong>运行状态</strong>：线程处于运行状态，主要是在运行线程中的代码块。</li><li><strong>阻塞状态</strong>：在线程运行过程中，当线程代码块中调用了线程的sleep（），yield（），同步锁定或者其他使线程阻塞的方法，此时的线程无法继续运行下去，进入了阻塞状态（线程代码块的自身逻辑混乱也可以使线程阻塞）。<strong>当造成线程阻塞的阻塞事件解决之后，线程不会回到运行状态，而是回到就绪状态，再次等待CPU的调度运行。</strong>需要注意的是，<em><strong>阻塞并不意味着线程运行终止</strong></em></li><li><strong>死亡状态</strong>：<em>当线程成功运行完所有的代码之后，线程就结束了，也进入了死亡状态。线程一旦死亡，就无法再次启动</em>，注意这里和阻塞状态的不同。<em>同样的，当线程运行一半的时候被强行结束终止，也算进入死亡状态，也无法被再次启动。</em></li></ul><h2 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h2><p>Java中的thread类自带有线程的一些方法，这些方法可以让线程睡眠，插队，提高线程调度的优先级等等，它们提供了改变线程状态的操作手段。(不过在JDK帮助文档中，一些方法已经不推荐使用)</p><h3 id="线程方法中的一些有趣的地方"><a href="#线程方法中的一些有趣的地方" class="headerlink" title="线程方法中的一些有趣的地方"></a>线程方法中的一些有趣的地方</h3><ul><li><p>线程睡眠是以毫秒为单位的。一秒等于一千毫秒。一般在测试程序中调用睡眠方法，是为了提高程序问题的发生性，或者说为了发现bug</p></li><li><p>线程停止，由于Java中自带的停止方法不太好用，所以一般都是自己写一个停止的方法，标定一个布尔类型的Flag作为线程执行的标志，当flag为真时线程运行，当flag为假时线程停止。</p></li><li><p>线程礼让是将正在运行的线程暂停回到就绪状态，而不是变为阻塞状态。有趣的是礼让不是一定会成功的，因为线程由就绪状态进入运行状态是由CPU随机调度的。所以礼让的线程有可能在下次的调度中再次提前调度，提前运行。</p></li><li><p>线程插队（join方法），强制阻塞其他线程，只有插入的线程执行完成之后，其他线程才能继续执行</p></li><li><p>线程虽然有优先级的区别（1-10），但是在实际运行中还是得看CPU的心情调度运行，优先级高只是被调度的概率高一点。Java中自带有线程优先级的查看和改变方法（线程的优先级设置最好在线程启动之前）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ttp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//主线程的默认优先级</span><br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;---&gt;&quot;</span> + Thread.currentThread().getPriority());<br>        <span class="hljs-type">MyPriorty</span> <span class="hljs-variable">mm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPriorty</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mm);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mm);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mm);<br><br><br>        <br>        t1.setPriority(<span class="hljs-number">10</span>);<br>        t1.start();<br><br>        t2.setPriority(<span class="hljs-number">4</span>);<br>        t2.start();<br><br>        t3.setPriority(<span class="hljs-number">6</span>);<br>        t3.start();<br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Runnable接口实现接口，run方法为打印线程名称和线程的优先级</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPriorty</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;---&gt;&quot;</span> + Thread.currentThread().getPriority());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//这里的输出有多种结果，因为优先级只是增加了线程被调度运行的机率</span><br></code></pre></td></tr></table></figure></li><li><p>用户线程和守护线程。守护线程的作用是保证用户线程的执行过程正常，例如Java中的内存回收线程和后台记录操作日志等等，这些都是守护线程。虚拟机必须等待用户线程执行完毕，不用等待守护线程执行完毕。当用户线程完成后，虚拟机就自动关闭，守护线程也就自动死亡了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//Java的Thread类自带设置守护线程的方法</span><br>Thread.setdaemon(<span class="hljs-literal">true</span>) <span class="hljs-comment">//设置为守护线程</span><br><span class="hljs-comment">//一般我们创建的线程默认都是用户线程</span><br></code></pre></td></tr></table></figure></li><li><p>线程同步。<strong>线程同步是出现多个线程访问同一个对象并都想对其进行操作的时候必须考虑的问题</strong>。不进行线程同步（并发）控制的多线程是不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-comment">//线程不安全，出现了-1张票以及有两个线程拿到同一张票的错误，所以这是一个不安全的线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test05</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">buyTicket</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">buyTicket</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b1,<span class="hljs-string">&quot;you&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b1,<span class="hljs-string">&quot;i&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b1,<span class="hljs-string">&quot;he&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b1,<span class="hljs-string">&quot;she&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        t4.start();<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">buyTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-comment">//剩余票数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            buy();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(ticketNums &lt;= <span class="hljs-number">0</span>)&#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;买到了第&quot;</span> + ticketNums-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程同步实质上是一个等待机制。线程同步时会将多个线程放入对象等待池中进行排队（队列），等待前一个线程执行操作完毕，再有下一个线程进行执行操作。每个对象都有一个独有的锁（排他锁），每个线程执行时都会获得对象的排他锁，这样只有获得锁的线程可以对对象进行操作，执行结束后排他锁被下一个线程获得。总结来说，线程同步的形成条件就是：队列+锁</p><p>线程同步也有一些存在的问题</p><ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li><li>在多线程竞争下，加锁，释放锁会导致较多的上下文切换和调度延时，引起性能问题</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题</li></ul><p>​</p></li></ul><p></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
